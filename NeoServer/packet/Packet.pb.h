// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Packet.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Packet_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Packet_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Packet_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Packet_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Packet_2eproto;
namespace neo {
class GAME_OBJECT;
struct GAME_OBJECTDefaultTypeInternal;
extern GAME_OBJECTDefaultTypeInternal _GAME_OBJECT_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class P_C_NOTIFY_CHANNEL_UNREGISTER;
struct P_C_NOTIFY_CHANNEL_UNREGISTERDefaultTypeInternal;
extern P_C_NOTIFY_CHANNEL_UNREGISTERDefaultTypeInternal _P_C_NOTIFY_CHANNEL_UNREGISTER_default_instance_;
class P_C_NOTIFY_MAP_REGISTER;
struct P_C_NOTIFY_MAP_REGISTERDefaultTypeInternal;
extern P_C_NOTIFY_MAP_REGISTERDefaultTypeInternal _P_C_NOTIFY_MAP_REGISTER_default_instance_;
class P_C_NOTIFY_PING;
struct P_C_NOTIFY_PINGDefaultTypeInternal;
extern P_C_NOTIFY_PINGDefaultTypeInternal _P_C_NOTIFY_PING_default_instance_;
class P_C_NOTIFY_RESPAWN;
struct P_C_NOTIFY_RESPAWNDefaultTypeInternal;
extern P_C_NOTIFY_RESPAWNDefaultTypeInternal _P_C_NOTIFY_RESPAWN_default_instance_;
class P_C_REQ_ATTACK_EVENT;
struct P_C_REQ_ATTACK_EVENTDefaultTypeInternal;
extern P_C_REQ_ATTACK_EVENTDefaultTypeInternal _P_C_REQ_ATTACK_EVENT_default_instance_;
class P_C_REQ_ATTACK_RANGE_EVENT;
struct P_C_REQ_ATTACK_RANGE_EVENTDefaultTypeInternal;
extern P_C_REQ_ATTACK_RANGE_EVENTDefaultTypeInternal _P_C_REQ_ATTACK_RANGE_EVENT_default_instance_;
class P_C_REQ_ATTACK_RANGE_HIT_EVENT;
struct P_C_REQ_ATTACK_RANGE_HIT_EVENTDefaultTypeInternal;
extern P_C_REQ_ATTACK_RANGE_HIT_EVENTDefaultTypeInternal _P_C_REQ_ATTACK_RANGE_HIT_EVENT_default_instance_;
class P_C_REQ_CHANNEL_REGISTER;
struct P_C_REQ_CHANNEL_REGISTERDefaultTypeInternal;
extern P_C_REQ_CHANNEL_REGISTERDefaultTypeInternal _P_C_REQ_CHANNEL_REGISTER_default_instance_;
class P_C_REQ_CHARACTER_MAP_UNREGISTER;
struct P_C_REQ_CHARACTER_MAP_UNREGISTERDefaultTypeInternal;
extern P_C_REQ_CHARACTER_MAP_UNREGISTERDefaultTypeInternal _P_C_REQ_CHARACTER_MAP_UNREGISTER_default_instance_;
class P_C_REQ_CHARACTER_REGISTER;
struct P_C_REQ_CHARACTER_REGISTERDefaultTypeInternal;
extern P_C_REQ_CHARACTER_REGISTERDefaultTypeInternal _P_C_REQ_CHARACTER_REGISTER_default_instance_;
class P_C_REQ_LOGIN;
struct P_C_REQ_LOGINDefaultTypeInternal;
extern P_C_REQ_LOGINDefaultTypeInternal _P_C_REQ_LOGIN_default_instance_;
class P_C_REQ_LOGOUT;
struct P_C_REQ_LOGOUTDefaultTypeInternal;
extern P_C_REQ_LOGOUTDefaultTypeInternal _P_C_REQ_LOGOUT_default_instance_;
class P_C_UPDATE_CHAR_POSITION;
struct P_C_UPDATE_CHAR_POSITIONDefaultTypeInternal;
extern P_C_UPDATE_CHAR_POSITIONDefaultTypeInternal _P_C_UPDATE_CHAR_POSITION_default_instance_;
class P_NOTIFY_OBJECT_UPDATE;
struct P_NOTIFY_OBJECT_UPDATEDefaultTypeInternal;
extern P_NOTIFY_OBJECT_UPDATEDefaultTypeInternal _P_NOTIFY_OBJECT_UPDATE_default_instance_;
class P_S_NOTIFY_ATTACK_ANI_EVENT;
struct P_S_NOTIFY_ATTACK_ANI_EVENTDefaultTypeInternal;
extern P_S_NOTIFY_ATTACK_ANI_EVENTDefaultTypeInternal _P_S_NOTIFY_ATTACK_ANI_EVENT_default_instance_;
class P_S_NOTIFY_ATTACK_EVENT;
struct P_S_NOTIFY_ATTACK_EVENTDefaultTypeInternal;
extern P_S_NOTIFY_ATTACK_EVENTDefaultTypeInternal _P_S_NOTIFY_ATTACK_EVENT_default_instance_;
class P_S_NOTIFY_CHANNEL_INFO;
struct P_S_NOTIFY_CHANNEL_INFODefaultTypeInternal;
extern P_S_NOTIFY_CHANNEL_INFODefaultTypeInternal _P_S_NOTIFY_CHANNEL_INFO_default_instance_;
class P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA;
struct P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATADefaultTypeInternal;
extern P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATADefaultTypeInternal _P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA_default_instance_;
class P_S_NOTIFY_CHARACTER_INFO;
struct P_S_NOTIFY_CHARACTER_INFODefaultTypeInternal;
extern P_S_NOTIFY_CHARACTER_INFODefaultTypeInternal _P_S_NOTIFY_CHARACTER_INFO_default_instance_;
class P_S_NOTIFY_CHARACTER_MAP_UNREGISTER;
struct P_S_NOTIFY_CHARACTER_MAP_UNREGISTERDefaultTypeInternal;
extern P_S_NOTIFY_CHARACTER_MAP_UNREGISTERDefaultTypeInternal _P_S_NOTIFY_CHARACTER_MAP_UNREGISTER_default_instance_;
class P_S_NOTIFY_EFFECT_EVENT;
struct P_S_NOTIFY_EFFECT_EVENTDefaultTypeInternal;
extern P_S_NOTIFY_EFFECT_EVENTDefaultTypeInternal _P_S_NOTIFY_EFFECT_EVENT_default_instance_;
class P_S_NOTIFY_MONSTER_INFO;
struct P_S_NOTIFY_MONSTER_INFODefaultTypeInternal;
extern P_S_NOTIFY_MONSTER_INFODefaultTypeInternal _P_S_NOTIFY_MONSTER_INFO_default_instance_;
class P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA;
struct P_S_NOTIFY_MONSTER_INFO_MONSTER_DATADefaultTypeInternal;
extern P_S_NOTIFY_MONSTER_INFO_MONSTER_DATADefaultTypeInternal _P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA_default_instance_;
class P_S_NOTIFY_MONSTER_MAP_REGISTER;
struct P_S_NOTIFY_MONSTER_MAP_REGISTERDefaultTypeInternal;
extern P_S_NOTIFY_MONSTER_MAP_REGISTERDefaultTypeInternal _P_S_NOTIFY_MONSTER_MAP_REGISTER_default_instance_;
class P_S_NOTIFY_MONSTER_MAP_UNREGISTER;
struct P_S_NOTIFY_MONSTER_MAP_UNREGISTERDefaultTypeInternal;
extern P_S_NOTIFY_MONSTER_MAP_UNREGISTERDefaultTypeInternal _P_S_NOTIFY_MONSTER_MAP_UNREGISTER_default_instance_;
class P_S_NOTIFY_MONSTER_POSITION;
struct P_S_NOTIFY_MONSTER_POSITIONDefaultTypeInternal;
extern P_S_NOTIFY_MONSTER_POSITIONDefaultTypeInternal _P_S_NOTIFY_MONSTER_POSITION_default_instance_;
class P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION;
struct P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITIONDefaultTypeInternal;
extern P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITIONDefaultTypeInternal _P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION_default_instance_;
class P_S_NOTIFY_PING;
struct P_S_NOTIFY_PINGDefaultTypeInternal;
extern P_S_NOTIFY_PINGDefaultTypeInternal _P_S_NOTIFY_PING_default_instance_;
class P_S_RES_ATTACK_EVENT;
struct P_S_RES_ATTACK_EVENTDefaultTypeInternal;
extern P_S_RES_ATTACK_EVENTDefaultTypeInternal _P_S_RES_ATTACK_EVENT_default_instance_;
class P_S_RES_CHANNEL_REGISTER;
struct P_S_RES_CHANNEL_REGISTERDefaultTypeInternal;
extern P_S_RES_CHANNEL_REGISTERDefaultTypeInternal _P_S_RES_CHANNEL_REGISTER_default_instance_;
class P_S_RES_CHARACTER_REGISTER;
struct P_S_RES_CHARACTER_REGISTERDefaultTypeInternal;
extern P_S_RES_CHARACTER_REGISTERDefaultTypeInternal _P_S_RES_CHARACTER_REGISTER_default_instance_;
class P_S_RES_LOGIN;
struct P_S_RES_LOGINDefaultTypeInternal;
extern P_S_RES_LOGINDefaultTypeInternal _P_S_RES_LOGIN_default_instance_;
class P_S_RES_LOGOUT;
struct P_S_RES_LOGOUTDefaultTypeInternal;
extern P_S_RES_LOGOUTDefaultTypeInternal _P_S_RES_LOGOUT_default_instance_;
}  // namespace neo
PROTOBUF_NAMESPACE_OPEN
template<> ::neo::GAME_OBJECT* Arena::CreateMaybeMessage<::neo::GAME_OBJECT>(Arena*);
template<> ::neo::Header* Arena::CreateMaybeMessage<::neo::Header>(Arena*);
template<> ::neo::P_C_NOTIFY_CHANNEL_UNREGISTER* Arena::CreateMaybeMessage<::neo::P_C_NOTIFY_CHANNEL_UNREGISTER>(Arena*);
template<> ::neo::P_C_NOTIFY_MAP_REGISTER* Arena::CreateMaybeMessage<::neo::P_C_NOTIFY_MAP_REGISTER>(Arena*);
template<> ::neo::P_C_NOTIFY_PING* Arena::CreateMaybeMessage<::neo::P_C_NOTIFY_PING>(Arena*);
template<> ::neo::P_C_NOTIFY_RESPAWN* Arena::CreateMaybeMessage<::neo::P_C_NOTIFY_RESPAWN>(Arena*);
template<> ::neo::P_C_REQ_ATTACK_EVENT* Arena::CreateMaybeMessage<::neo::P_C_REQ_ATTACK_EVENT>(Arena*);
template<> ::neo::P_C_REQ_ATTACK_RANGE_EVENT* Arena::CreateMaybeMessage<::neo::P_C_REQ_ATTACK_RANGE_EVENT>(Arena*);
template<> ::neo::P_C_REQ_ATTACK_RANGE_HIT_EVENT* Arena::CreateMaybeMessage<::neo::P_C_REQ_ATTACK_RANGE_HIT_EVENT>(Arena*);
template<> ::neo::P_C_REQ_CHANNEL_REGISTER* Arena::CreateMaybeMessage<::neo::P_C_REQ_CHANNEL_REGISTER>(Arena*);
template<> ::neo::P_C_REQ_CHARACTER_MAP_UNREGISTER* Arena::CreateMaybeMessage<::neo::P_C_REQ_CHARACTER_MAP_UNREGISTER>(Arena*);
template<> ::neo::P_C_REQ_CHARACTER_REGISTER* Arena::CreateMaybeMessage<::neo::P_C_REQ_CHARACTER_REGISTER>(Arena*);
template<> ::neo::P_C_REQ_LOGIN* Arena::CreateMaybeMessage<::neo::P_C_REQ_LOGIN>(Arena*);
template<> ::neo::P_C_REQ_LOGOUT* Arena::CreateMaybeMessage<::neo::P_C_REQ_LOGOUT>(Arena*);
template<> ::neo::P_C_UPDATE_CHAR_POSITION* Arena::CreateMaybeMessage<::neo::P_C_UPDATE_CHAR_POSITION>(Arena*);
template<> ::neo::P_NOTIFY_OBJECT_UPDATE* Arena::CreateMaybeMessage<::neo::P_NOTIFY_OBJECT_UPDATE>(Arena*);
template<> ::neo::P_S_NOTIFY_ATTACK_ANI_EVENT* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_ATTACK_ANI_EVENT>(Arena*);
template<> ::neo::P_S_NOTIFY_ATTACK_EVENT* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_ATTACK_EVENT>(Arena*);
template<> ::neo::P_S_NOTIFY_CHANNEL_INFO* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_CHANNEL_INFO>(Arena*);
template<> ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA>(Arena*);
template<> ::neo::P_S_NOTIFY_CHARACTER_INFO* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_CHARACTER_INFO>(Arena*);
template<> ::neo::P_S_NOTIFY_CHARACTER_MAP_UNREGISTER* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_CHARACTER_MAP_UNREGISTER>(Arena*);
template<> ::neo::P_S_NOTIFY_EFFECT_EVENT* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_EFFECT_EVENT>(Arena*);
template<> ::neo::P_S_NOTIFY_MONSTER_INFO* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_MONSTER_INFO>(Arena*);
template<> ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA>(Arena*);
template<> ::neo::P_S_NOTIFY_MONSTER_MAP_REGISTER* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_MONSTER_MAP_REGISTER>(Arena*);
template<> ::neo::P_S_NOTIFY_MONSTER_MAP_UNREGISTER* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_MONSTER_MAP_UNREGISTER>(Arena*);
template<> ::neo::P_S_NOTIFY_MONSTER_POSITION* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_MONSTER_POSITION>(Arena*);
template<> ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION>(Arena*);
template<> ::neo::P_S_NOTIFY_PING* Arena::CreateMaybeMessage<::neo::P_S_NOTIFY_PING>(Arena*);
template<> ::neo::P_S_RES_ATTACK_EVENT* Arena::CreateMaybeMessage<::neo::P_S_RES_ATTACK_EVENT>(Arena*);
template<> ::neo::P_S_RES_CHANNEL_REGISTER* Arena::CreateMaybeMessage<::neo::P_S_RES_CHANNEL_REGISTER>(Arena*);
template<> ::neo::P_S_RES_CHARACTER_REGISTER* Arena::CreateMaybeMessage<::neo::P_S_RES_CHARACTER_REGISTER>(Arena*);
template<> ::neo::P_S_RES_LOGIN* Arena::CreateMaybeMessage<::neo::P_S_RES_LOGIN>(Arena*);
template<> ::neo::P_S_RES_LOGOUT* Arena::CreateMaybeMessage<::neo::P_S_RES_LOGOUT>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace neo {

enum PacketID : int {
  PI_TEST_PACKET = 0,
  PI_C_NOTIFY_PING = 1,
  PI_S_NOTIFY_PING = 2,
  PI_C_UPDATE_CHAR_POSITION = 100,
  PI_S_NOTIFY_CHAR_POSITION = 200,
  PI_S_NOTIFY_CHAR_UDPATE = 201,
  PI_S_NOTIFY_MONSTER_POSITION = 300,
  PI_S_RES_LOGOUT = 998,
  PI_C_REQ_LOGOUT = 999,
  PI_C_REQ_LOGIN = 1000,
  PI_S_RES_LOGIN = 2000,
  PI_C_REQ_CHANNEL_REGISTER = 3000,
  PI_S_RES_CHANNEL_REGISTER = 3001,
  PI_C_NOTIFY_CHANNEL_UNREGISTER = 3002,
  PI_C_NOTIFY_MAP_REGISTER = 3003,
  PI_C_REQ_CHARACTER_REGISTER = 3100,
  PI_S_RES_CHARACTER_REGISTER = 3101,
  PI_C_REQ_CHARACTER_MAP_UNREGISTER = 3102,
  PI_S_NOTIFY_CHARACTER_MAP_UNREGISTER = 3103,
  PI_S_NOTIFY_MONSTER_MAP_REGISTER = 3110,
  PI_S_NOTIFY_MONSTER_MAP_UNREGISTER = 3111,
  PI_S_NOTIFY_ATTACK_ANI_EVENT = 3150,
  PI_S_NOTIFY_CHARACTER_INFO = 3202,
  PI_S_NOTIFY_MONSTER_INFO = 3300,
  PI_C_REQ_ATTACK_RANGE_HIT_EVENT = 3497,
  PI_S_NOTIFY_EFFECT_EVENT = 3498,
  PI_C_REQ_ATTACK_RANGE_EVENT = 3499,
  PI_C_REQ_ATTACK_EVENT = 3500,
  PI_S_RES_ATTACK_EVENT = 3501,
  PI_S_NOTIFY_ATTACK_EVENT = 3502,
  PI_C_NOTIFY_RESPAWN = 3503,
  PI_NOTIFY_OBJECT_UPDATE = 3510,
  PI_S_NOTIFY_CHANNEL_INFO = 3999,
  PacketID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PacketID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PacketID_IsValid(int value);
constexpr PacketID PacketID_MIN = PI_TEST_PACKET;
constexpr PacketID PacketID_MAX = PI_S_NOTIFY_CHANNEL_INFO;
constexpr int PacketID_ARRAYSIZE = PacketID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PacketID_descriptor();
template<typename T>
inline const std::string& PacketID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PacketID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PacketID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PacketID_descriptor(), enum_t_value);
}
inline bool PacketID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PacketID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PacketID>(
    PacketID_descriptor(), name, value);
}
enum PacketResult : int {
  SUCCESS = 0,
  FAILED = 1,
  PacketResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PacketResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PacketResult_IsValid(int value);
constexpr PacketResult PacketResult_MIN = SUCCESS;
constexpr PacketResult PacketResult_MAX = FAILED;
constexpr int PacketResult_ARRAYSIZE = PacketResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PacketResult_descriptor();
template<typename T>
inline const std::string& PacketResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PacketResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PacketResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PacketResult_descriptor(), enum_t_value);
}
inline bool PacketResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PacketResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PacketResult>(
    PacketResult_descriptor(), name, value);
}
// ===================================================================

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .neo.PacketID id = 1;
  void clear_id();
  ::neo::PacketID id() const;
  void set_id(::neo::PacketID value);
  private:
  ::neo::PacketID _internal_id() const;
  void _internal_set_id(::neo::PacketID value);
  public:

  // int32 size = 2;
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int id_;
    int32_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_LOGIN) */ {
 public:
  inline P_C_REQ_LOGIN() : P_C_REQ_LOGIN(nullptr) {}
  ~P_C_REQ_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_LOGIN(const P_C_REQ_LOGIN& from);
  P_C_REQ_LOGIN(P_C_REQ_LOGIN&& from) noexcept
    : P_C_REQ_LOGIN() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_LOGIN& operator=(const P_C_REQ_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_LOGIN& operator=(P_C_REQ_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_LOGIN* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_LOGIN*>(
               &_P_C_REQ_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(P_C_REQ_LOGIN& a, P_C_REQ_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_LOGIN& from) {
    P_C_REQ_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_LOGIN";
  }
  protected:
  explicit P_C_REQ_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes uuid = 2;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_RES_LOGOUT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_RES_LOGOUT) */ {
 public:
  inline P_S_RES_LOGOUT() : P_S_RES_LOGOUT(nullptr) {}
  ~P_S_RES_LOGOUT() override;
  explicit PROTOBUF_CONSTEXPR P_S_RES_LOGOUT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_RES_LOGOUT(const P_S_RES_LOGOUT& from);
  P_S_RES_LOGOUT(P_S_RES_LOGOUT&& from) noexcept
    : P_S_RES_LOGOUT() {
    *this = ::std::move(from);
  }

  inline P_S_RES_LOGOUT& operator=(const P_S_RES_LOGOUT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_RES_LOGOUT& operator=(P_S_RES_LOGOUT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_RES_LOGOUT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_RES_LOGOUT* internal_default_instance() {
    return reinterpret_cast<const P_S_RES_LOGOUT*>(
               &_P_S_RES_LOGOUT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(P_S_RES_LOGOUT& a, P_S_RES_LOGOUT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_RES_LOGOUT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_RES_LOGOUT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_RES_LOGOUT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_RES_LOGOUT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_RES_LOGOUT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_RES_LOGOUT& from) {
    P_S_RES_LOGOUT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_RES_LOGOUT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_RES_LOGOUT";
  }
  protected:
  explicit P_S_RES_LOGOUT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_RES_LOGOUT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_LOGOUT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_LOGOUT) */ {
 public:
  inline P_C_REQ_LOGOUT() : P_C_REQ_LOGOUT(nullptr) {}
  ~P_C_REQ_LOGOUT() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_LOGOUT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_LOGOUT(const P_C_REQ_LOGOUT& from);
  P_C_REQ_LOGOUT(P_C_REQ_LOGOUT&& from) noexcept
    : P_C_REQ_LOGOUT() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_LOGOUT& operator=(const P_C_REQ_LOGOUT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_LOGOUT& operator=(P_C_REQ_LOGOUT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_LOGOUT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_LOGOUT* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_LOGOUT*>(
               &_P_C_REQ_LOGOUT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(P_C_REQ_LOGOUT& a, P_C_REQ_LOGOUT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_LOGOUT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_LOGOUT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_LOGOUT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_LOGOUT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_LOGOUT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_LOGOUT& from) {
    P_C_REQ_LOGOUT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_LOGOUT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_LOGOUT";
  }
  protected:
  explicit P_C_REQ_LOGOUT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kMapIDFieldNumber = 1,
  };
  // string user = 2;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_LOGOUT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_RES_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_RES_LOGIN) */ {
 public:
  inline P_S_RES_LOGIN() : P_S_RES_LOGIN(nullptr) {}
  ~P_S_RES_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR P_S_RES_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_RES_LOGIN(const P_S_RES_LOGIN& from);
  P_S_RES_LOGIN(P_S_RES_LOGIN&& from) noexcept
    : P_S_RES_LOGIN() {
    *this = ::std::move(from);
  }

  inline P_S_RES_LOGIN& operator=(const P_S_RES_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_RES_LOGIN& operator=(P_S_RES_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_RES_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_RES_LOGIN* internal_default_instance() {
    return reinterpret_cast<const P_S_RES_LOGIN*>(
               &_P_S_RES_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(P_S_RES_LOGIN& a, P_S_RES_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_RES_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_RES_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_RES_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_RES_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_RES_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_RES_LOGIN& from) {
    P_S_RES_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_RES_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_RES_LOGIN";
  }
  protected:
  explicit P_S_RES_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .neo.PacketResult result = 1;
  void clear_result();
  ::neo::PacketResult result() const;
  void set_result(::neo::PacketResult value);
  private:
  ::neo::PacketResult _internal_result() const;
  void _internal_set_result(::neo::PacketResult value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_RES_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_NOTIFY_PING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_NOTIFY_PING) */ {
 public:
  inline P_C_NOTIFY_PING() : P_C_NOTIFY_PING(nullptr) {}
  ~P_C_NOTIFY_PING() override;
  explicit PROTOBUF_CONSTEXPR P_C_NOTIFY_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_NOTIFY_PING(const P_C_NOTIFY_PING& from);
  P_C_NOTIFY_PING(P_C_NOTIFY_PING&& from) noexcept
    : P_C_NOTIFY_PING() {
    *this = ::std::move(from);
  }

  inline P_C_NOTIFY_PING& operator=(const P_C_NOTIFY_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_NOTIFY_PING& operator=(P_C_NOTIFY_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_NOTIFY_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_NOTIFY_PING* internal_default_instance() {
    return reinterpret_cast<const P_C_NOTIFY_PING*>(
               &_P_C_NOTIFY_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(P_C_NOTIFY_PING& a, P_C_NOTIFY_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_NOTIFY_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_NOTIFY_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_NOTIFY_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_NOTIFY_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_NOTIFY_PING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_NOTIFY_PING& from) {
    P_C_NOTIFY_PING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_NOTIFY_PING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_NOTIFY_PING";
  }
  protected:
  explicit P_C_NOTIFY_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // int64 time = 1;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_NOTIFY_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_PING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_PING) */ {
 public:
  inline P_S_NOTIFY_PING() : P_S_NOTIFY_PING(nullptr) {}
  ~P_S_NOTIFY_PING() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_PING(const P_S_NOTIFY_PING& from);
  P_S_NOTIFY_PING(P_S_NOTIFY_PING&& from) noexcept
    : P_S_NOTIFY_PING() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_PING& operator=(const P_S_NOTIFY_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_PING& operator=(P_S_NOTIFY_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_PING* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_PING*>(
               &_P_S_NOTIFY_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(P_S_NOTIFY_PING& a, P_S_NOTIFY_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_PING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_PING& from) {
    P_S_NOTIFY_PING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_PING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_PING";
  }
  protected:
  explicit P_S_NOTIFY_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // int64 time = 1;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_UPDATE_CHAR_POSITION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_UPDATE_CHAR_POSITION) */ {
 public:
  inline P_C_UPDATE_CHAR_POSITION() : P_C_UPDATE_CHAR_POSITION(nullptr) {}
  ~P_C_UPDATE_CHAR_POSITION() override;
  explicit PROTOBUF_CONSTEXPR P_C_UPDATE_CHAR_POSITION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_UPDATE_CHAR_POSITION(const P_C_UPDATE_CHAR_POSITION& from);
  P_C_UPDATE_CHAR_POSITION(P_C_UPDATE_CHAR_POSITION&& from) noexcept
    : P_C_UPDATE_CHAR_POSITION() {
    *this = ::std::move(from);
  }

  inline P_C_UPDATE_CHAR_POSITION& operator=(const P_C_UPDATE_CHAR_POSITION& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_UPDATE_CHAR_POSITION& operator=(P_C_UPDATE_CHAR_POSITION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_UPDATE_CHAR_POSITION& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_UPDATE_CHAR_POSITION* internal_default_instance() {
    return reinterpret_cast<const P_C_UPDATE_CHAR_POSITION*>(
               &_P_C_UPDATE_CHAR_POSITION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(P_C_UPDATE_CHAR_POSITION& a, P_C_UPDATE_CHAR_POSITION& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_UPDATE_CHAR_POSITION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_UPDATE_CHAR_POSITION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_UPDATE_CHAR_POSITION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_UPDATE_CHAR_POSITION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_UPDATE_CHAR_POSITION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_UPDATE_CHAR_POSITION& from) {
    P_C_UPDATE_CHAR_POSITION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_UPDATE_CHAR_POSITION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_UPDATE_CHAR_POSITION";
  }
  protected:
  explicit P_C_UPDATE_CHAR_POSITION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_UPDATE_CHAR_POSITION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class GAME_OBJECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.GAME_OBJECT) */ {
 public:
  inline GAME_OBJECT() : GAME_OBJECT(nullptr) {}
  ~GAME_OBJECT() override;
  explicit PROTOBUF_CONSTEXPR GAME_OBJECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GAME_OBJECT(const GAME_OBJECT& from);
  GAME_OBJECT(GAME_OBJECT&& from) noexcept
    : GAME_OBJECT() {
    *this = ::std::move(from);
  }

  inline GAME_OBJECT& operator=(const GAME_OBJECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline GAME_OBJECT& operator=(GAME_OBJECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GAME_OBJECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const GAME_OBJECT* internal_default_instance() {
    return reinterpret_cast<const GAME_OBJECT*>(
               &_GAME_OBJECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GAME_OBJECT& a, GAME_OBJECT& b) {
    a.Swap(&b);
  }
  inline void Swap(GAME_OBJECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GAME_OBJECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GAME_OBJECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GAME_OBJECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GAME_OBJECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GAME_OBJECT& from) {
    GAME_OBJECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GAME_OBJECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.GAME_OBJECT";
  }
  protected:
  explicit GAME_OBJECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:neo.GAME_OBJECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION) */ {
 public:
  inline P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION() : P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION(nullptr) {}
  ~P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION(const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& from);
  P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION(P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION&& from) noexcept
    : P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& operator=(const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& operator=(P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION*>(
               &_P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& a, P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& from) {
    P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION";
  }
  protected:
  explicit P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kVoleoctiyXFieldNumber = 5,
    kVoleoctiyYFieldNumber = 6,
    kSpeedFieldNumber = 7,
    kAnimationFieldNumber = 8,
  };
  // bytes object_id = 1;
  void clear_object_id();
  const std::string& object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_id();
  PROTOBUF_NODISCARD std::string* release_object_id();
  void set_allocated_object_id(std::string* object_id);
  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const std::string& value);
  std::string* _internal_mutable_object_id();
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float voleoctiy_x = 5;
  void clear_voleoctiy_x();
  float voleoctiy_x() const;
  void set_voleoctiy_x(float value);
  private:
  float _internal_voleoctiy_x() const;
  void _internal_set_voleoctiy_x(float value);
  public:

  // float voleoctiy_y = 6;
  void clear_voleoctiy_y();
  float voleoctiy_y() const;
  void set_voleoctiy_y(float value);
  private:
  float _internal_voleoctiy_y() const;
  void _internal_set_voleoctiy_y(float value);
  public:

  // float speed = 7;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // int32 animation = 8;
  void clear_animation();
  int32_t animation() const;
  void set_animation(int32_t value);
  private:
  int32_t _internal_animation() const;
  void _internal_set_animation(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_id_;
    float x_;
    float y_;
    float z_;
    float voleoctiy_x_;
    float voleoctiy_y_;
    float speed_;
    int32_t animation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_MONSTER_POSITION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_MONSTER_POSITION) */ {
 public:
  inline P_S_NOTIFY_MONSTER_POSITION() : P_S_NOTIFY_MONSTER_POSITION(nullptr) {}
  ~P_S_NOTIFY_MONSTER_POSITION() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_MONSTER_POSITION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_MONSTER_POSITION(const P_S_NOTIFY_MONSTER_POSITION& from);
  P_S_NOTIFY_MONSTER_POSITION(P_S_NOTIFY_MONSTER_POSITION&& from) noexcept
    : P_S_NOTIFY_MONSTER_POSITION() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_MONSTER_POSITION& operator=(const P_S_NOTIFY_MONSTER_POSITION& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_MONSTER_POSITION& operator=(P_S_NOTIFY_MONSTER_POSITION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_MONSTER_POSITION& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_MONSTER_POSITION* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_MONSTER_POSITION*>(
               &_P_S_NOTIFY_MONSTER_POSITION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(P_S_NOTIFY_MONSTER_POSITION& a, P_S_NOTIFY_MONSTER_POSITION& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_MONSTER_POSITION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_MONSTER_POSITION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_MONSTER_POSITION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_MONSTER_POSITION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_MONSTER_POSITION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_MONSTER_POSITION& from) {
    P_S_NOTIFY_MONSTER_POSITION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_MONSTER_POSITION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_MONSTER_POSITION";
  }
  protected:
  explicit P_S_NOTIFY_MONSTER_POSITION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION MONSTER_POSITION;

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterPositionFieldNumber = 1,
  };
  // repeated .neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION monster_position = 1;
  int monster_position_size() const;
  private:
  int _internal_monster_position_size() const;
  public:
  void clear_monster_position();
  ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* mutable_monster_position(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION >*
      mutable_monster_position();
  private:
  const ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& _internal_monster_position(int index) const;
  ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* _internal_add_monster_position();
  public:
  const ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& monster_position(int index) const;
  ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* add_monster_position();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION >&
      monster_position() const;

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_MONSTER_POSITION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION > monster_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_CHANNEL_REGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_CHANNEL_REGISTER) */ {
 public:
  inline P_C_REQ_CHANNEL_REGISTER() : P_C_REQ_CHANNEL_REGISTER(nullptr) {}
  ~P_C_REQ_CHANNEL_REGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_CHANNEL_REGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_CHANNEL_REGISTER(const P_C_REQ_CHANNEL_REGISTER& from);
  P_C_REQ_CHANNEL_REGISTER(P_C_REQ_CHANNEL_REGISTER&& from) noexcept
    : P_C_REQ_CHANNEL_REGISTER() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_CHANNEL_REGISTER& operator=(const P_C_REQ_CHANNEL_REGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_CHANNEL_REGISTER& operator=(P_C_REQ_CHANNEL_REGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_CHANNEL_REGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_CHANNEL_REGISTER* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_CHANNEL_REGISTER*>(
               &_P_C_REQ_CHANNEL_REGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(P_C_REQ_CHANNEL_REGISTER& a, P_C_REQ_CHANNEL_REGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_CHANNEL_REGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_CHANNEL_REGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_CHANNEL_REGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_CHANNEL_REGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_CHANNEL_REGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_CHANNEL_REGISTER& from) {
    P_C_REQ_CHANNEL_REGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_CHANNEL_REGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_CHANNEL_REGISTER";
  }
  protected:
  explicit P_C_REQ_CHANNEL_REGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kChannelIDFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // int32 channelID = 2;
  void clear_channelid();
  int32_t channelid() const;
  void set_channelid(int32_t value);
  private:
  int32_t _internal_channelid() const;
  void _internal_set_channelid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_CHANNEL_REGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    int32_t channelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_RES_CHANNEL_REGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_RES_CHANNEL_REGISTER) */ {
 public:
  inline P_S_RES_CHANNEL_REGISTER() : P_S_RES_CHANNEL_REGISTER(nullptr) {}
  ~P_S_RES_CHANNEL_REGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_S_RES_CHANNEL_REGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_RES_CHANNEL_REGISTER(const P_S_RES_CHANNEL_REGISTER& from);
  P_S_RES_CHANNEL_REGISTER(P_S_RES_CHANNEL_REGISTER&& from) noexcept
    : P_S_RES_CHANNEL_REGISTER() {
    *this = ::std::move(from);
  }

  inline P_S_RES_CHANNEL_REGISTER& operator=(const P_S_RES_CHANNEL_REGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_RES_CHANNEL_REGISTER& operator=(P_S_RES_CHANNEL_REGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_RES_CHANNEL_REGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_RES_CHANNEL_REGISTER* internal_default_instance() {
    return reinterpret_cast<const P_S_RES_CHANNEL_REGISTER*>(
               &_P_S_RES_CHANNEL_REGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(P_S_RES_CHANNEL_REGISTER& a, P_S_RES_CHANNEL_REGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_RES_CHANNEL_REGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_RES_CHANNEL_REGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_RES_CHANNEL_REGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_RES_CHANNEL_REGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_RES_CHANNEL_REGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_RES_CHANNEL_REGISTER& from) {
    P_S_RES_CHANNEL_REGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_RES_CHANNEL_REGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_RES_CHANNEL_REGISTER";
  }
  protected:
  explicit P_S_RES_CHANNEL_REGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kResultFieldNumber = 1,
    kChannelIDFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .neo.PacketResult result = 1;
  void clear_result();
  ::neo::PacketResult result() const;
  void set_result(::neo::PacketResult value);
  private:
  ::neo::PacketResult _internal_result() const;
  void _internal_set_result(::neo::PacketResult value);
  public:

  // int32 channelID = 2;
  void clear_channelid();
  int32_t channelid() const;
  void set_channelid(int32_t value);
  private:
  int32_t _internal_channelid() const;
  void _internal_set_channelid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_RES_CHANNEL_REGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int result_;
    int32_t channelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_NOTIFY_CHANNEL_UNREGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_NOTIFY_CHANNEL_UNREGISTER) */ {
 public:
  inline P_C_NOTIFY_CHANNEL_UNREGISTER() : P_C_NOTIFY_CHANNEL_UNREGISTER(nullptr) {}
  ~P_C_NOTIFY_CHANNEL_UNREGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_C_NOTIFY_CHANNEL_UNREGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_NOTIFY_CHANNEL_UNREGISTER(const P_C_NOTIFY_CHANNEL_UNREGISTER& from);
  P_C_NOTIFY_CHANNEL_UNREGISTER(P_C_NOTIFY_CHANNEL_UNREGISTER&& from) noexcept
    : P_C_NOTIFY_CHANNEL_UNREGISTER() {
    *this = ::std::move(from);
  }

  inline P_C_NOTIFY_CHANNEL_UNREGISTER& operator=(const P_C_NOTIFY_CHANNEL_UNREGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_NOTIFY_CHANNEL_UNREGISTER& operator=(P_C_NOTIFY_CHANNEL_UNREGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_NOTIFY_CHANNEL_UNREGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_NOTIFY_CHANNEL_UNREGISTER* internal_default_instance() {
    return reinterpret_cast<const P_C_NOTIFY_CHANNEL_UNREGISTER*>(
               &_P_C_NOTIFY_CHANNEL_UNREGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(P_C_NOTIFY_CHANNEL_UNREGISTER& a, P_C_NOTIFY_CHANNEL_UNREGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_NOTIFY_CHANNEL_UNREGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_NOTIFY_CHANNEL_UNREGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_NOTIFY_CHANNEL_UNREGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_NOTIFY_CHANNEL_UNREGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_NOTIFY_CHANNEL_UNREGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_NOTIFY_CHANNEL_UNREGISTER& from) {
    P_C_NOTIFY_CHANNEL_UNREGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_NOTIFY_CHANNEL_UNREGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_NOTIFY_CHANNEL_UNREGISTER";
  }
  protected:
  explicit P_C_NOTIFY_CHANNEL_UNREGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kResultFieldNumber = 1,
    kChannelIDFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // int32 channelID = 2;
  void clear_channelid();
  int32_t channelid() const;
  void set_channelid(int32_t value);
  private:
  int32_t _internal_channelid() const;
  void _internal_set_channelid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_NOTIFY_CHANNEL_UNREGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t result_;
    int32_t channelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_NOTIFY_MAP_REGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_NOTIFY_MAP_REGISTER) */ {
 public:
  inline P_C_NOTIFY_MAP_REGISTER() : P_C_NOTIFY_MAP_REGISTER(nullptr) {}
  ~P_C_NOTIFY_MAP_REGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_C_NOTIFY_MAP_REGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_NOTIFY_MAP_REGISTER(const P_C_NOTIFY_MAP_REGISTER& from);
  P_C_NOTIFY_MAP_REGISTER(P_C_NOTIFY_MAP_REGISTER&& from) noexcept
    : P_C_NOTIFY_MAP_REGISTER() {
    *this = ::std::move(from);
  }

  inline P_C_NOTIFY_MAP_REGISTER& operator=(const P_C_NOTIFY_MAP_REGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_NOTIFY_MAP_REGISTER& operator=(P_C_NOTIFY_MAP_REGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_NOTIFY_MAP_REGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_NOTIFY_MAP_REGISTER* internal_default_instance() {
    return reinterpret_cast<const P_C_NOTIFY_MAP_REGISTER*>(
               &_P_C_NOTIFY_MAP_REGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(P_C_NOTIFY_MAP_REGISTER& a, P_C_NOTIFY_MAP_REGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_NOTIFY_MAP_REGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_NOTIFY_MAP_REGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_NOTIFY_MAP_REGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_NOTIFY_MAP_REGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_NOTIFY_MAP_REGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_NOTIFY_MAP_REGISTER& from) {
    P_C_NOTIFY_MAP_REGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_NOTIFY_MAP_REGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_NOTIFY_MAP_REGISTER";
  }
  protected:
  explicit P_C_NOTIFY_MAP_REGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kMapCountFieldNumber = 1,
    kIsRegisterFieldNumber = 2,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 mapCount = 1;
  void clear_mapcount();
  int32_t mapcount() const;
  void set_mapcount(int32_t value);
  private:
  int32_t _internal_mapcount() const;
  void _internal_set_mapcount(int32_t value);
  public:

  // bool isRegister = 2;
  void clear_isregister();
  bool isregister() const;
  void set_isregister(bool value);
  private:
  bool _internal_isregister() const;
  void _internal_set_isregister(bool value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_NOTIFY_MAP_REGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t mapcount_;
    bool isregister_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_CHARACTER_REGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_CHARACTER_REGISTER) */ {
 public:
  inline P_C_REQ_CHARACTER_REGISTER() : P_C_REQ_CHARACTER_REGISTER(nullptr) {}
  ~P_C_REQ_CHARACTER_REGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_CHARACTER_REGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_CHARACTER_REGISTER(const P_C_REQ_CHARACTER_REGISTER& from);
  P_C_REQ_CHARACTER_REGISTER(P_C_REQ_CHARACTER_REGISTER&& from) noexcept
    : P_C_REQ_CHARACTER_REGISTER() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_CHARACTER_REGISTER& operator=(const P_C_REQ_CHARACTER_REGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_CHARACTER_REGISTER& operator=(P_C_REQ_CHARACTER_REGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_CHARACTER_REGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_CHARACTER_REGISTER* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_CHARACTER_REGISTER*>(
               &_P_C_REQ_CHARACTER_REGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(P_C_REQ_CHARACTER_REGISTER& a, P_C_REQ_CHARACTER_REGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_CHARACTER_REGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_CHARACTER_REGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_CHARACTER_REGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_CHARACTER_REGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_CHARACTER_REGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_CHARACTER_REGISTER& from) {
    P_C_REQ_CHARACTER_REGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_CHARACTER_REGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_CHARACTER_REGISTER";
  }
  protected:
  explicit P_C_REQ_CHARACTER_REGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMapIDFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 mapID = 2;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_CHARACTER_REGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t mapid_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_RES_CHARACTER_REGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_RES_CHARACTER_REGISTER) */ {
 public:
  inline P_S_RES_CHARACTER_REGISTER() : P_S_RES_CHARACTER_REGISTER(nullptr) {}
  ~P_S_RES_CHARACTER_REGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_S_RES_CHARACTER_REGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_RES_CHARACTER_REGISTER(const P_S_RES_CHARACTER_REGISTER& from);
  P_S_RES_CHARACTER_REGISTER(P_S_RES_CHARACTER_REGISTER&& from) noexcept
    : P_S_RES_CHARACTER_REGISTER() {
    *this = ::std::move(from);
  }

  inline P_S_RES_CHARACTER_REGISTER& operator=(const P_S_RES_CHARACTER_REGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_RES_CHARACTER_REGISTER& operator=(P_S_RES_CHARACTER_REGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_RES_CHARACTER_REGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_RES_CHARACTER_REGISTER* internal_default_instance() {
    return reinterpret_cast<const P_S_RES_CHARACTER_REGISTER*>(
               &_P_S_RES_CHARACTER_REGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(P_S_RES_CHARACTER_REGISTER& a, P_S_RES_CHARACTER_REGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_RES_CHARACTER_REGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_RES_CHARACTER_REGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_RES_CHARACTER_REGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_RES_CHARACTER_REGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_RES_CHARACTER_REGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_RES_CHARACTER_REGISTER& from) {
    P_S_RES_CHARACTER_REGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_RES_CHARACTER_REGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_RES_CHARACTER_REGISTER";
  }
  protected:
  explicit P_S_RES_CHARACTER_REGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 3,
    kMsgFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .neo.GAME_OBJECT objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::neo::GAME_OBJECT* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::GAME_OBJECT >*
      mutable_objects();
  private:
  const ::neo::GAME_OBJECT& _internal_objects(int index) const;
  ::neo::GAME_OBJECT* _internal_add_objects();
  public:
  const ::neo::GAME_OBJECT& objects(int index) const;
  ::neo::GAME_OBJECT* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::GAME_OBJECT >&
      objects() const;

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_RES_CHARACTER_REGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::GAME_OBJECT > objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_CHARACTER_MAP_UNREGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER) */ {
 public:
  inline P_C_REQ_CHARACTER_MAP_UNREGISTER() : P_C_REQ_CHARACTER_MAP_UNREGISTER(nullptr) {}
  ~P_C_REQ_CHARACTER_MAP_UNREGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_CHARACTER_MAP_UNREGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_CHARACTER_MAP_UNREGISTER(const P_C_REQ_CHARACTER_MAP_UNREGISTER& from);
  P_C_REQ_CHARACTER_MAP_UNREGISTER(P_C_REQ_CHARACTER_MAP_UNREGISTER&& from) noexcept
    : P_C_REQ_CHARACTER_MAP_UNREGISTER() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_CHARACTER_MAP_UNREGISTER& operator=(const P_C_REQ_CHARACTER_MAP_UNREGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_CHARACTER_MAP_UNREGISTER& operator=(P_C_REQ_CHARACTER_MAP_UNREGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_CHARACTER_MAP_UNREGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_CHARACTER_MAP_UNREGISTER* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_CHARACTER_MAP_UNREGISTER*>(
               &_P_C_REQ_CHARACTER_MAP_UNREGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(P_C_REQ_CHARACTER_MAP_UNREGISTER& a, P_C_REQ_CHARACTER_MAP_UNREGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_CHARACTER_MAP_UNREGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_CHARACTER_MAP_UNREGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_CHARACTER_MAP_UNREGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_CHARACTER_MAP_UNREGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_CHARACTER_MAP_UNREGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_CHARACTER_MAP_UNREGISTER& from) {
    P_C_REQ_CHARACTER_MAP_UNREGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_CHARACTER_MAP_UNREGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_CHARACTER_MAP_UNREGISTER";
  }
  protected:
  explicit P_C_REQ_CHARACTER_MAP_UNREGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMapIDFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_CHARACTER_MAP_UNREGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER) */ {
 public:
  inline P_S_NOTIFY_CHARACTER_MAP_UNREGISTER() : P_S_NOTIFY_CHARACTER_MAP_UNREGISTER(nullptr) {}
  ~P_S_NOTIFY_CHARACTER_MAP_UNREGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_CHARACTER_MAP_UNREGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_CHARACTER_MAP_UNREGISTER(const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& from);
  P_S_NOTIFY_CHARACTER_MAP_UNREGISTER(P_S_NOTIFY_CHARACTER_MAP_UNREGISTER&& from) noexcept
    : P_S_NOTIFY_CHARACTER_MAP_UNREGISTER() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& operator=(const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& operator=(P_S_NOTIFY_CHARACTER_MAP_UNREGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER*>(
               &_P_S_NOTIFY_CHARACTER_MAP_UNREGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& a, P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_CHARACTER_MAP_UNREGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_CHARACTER_MAP_UNREGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_CHARACTER_MAP_UNREGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_CHARACTER_MAP_UNREGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_CHARACTER_MAP_UNREGISTER& from) {
    P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_CHARACTER_MAP_UNREGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER";
  }
  protected:
  explicit P_S_NOTIFY_CHARACTER_MAP_UNREGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMapIDFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_MONSTER_MAP_REGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER) */ {
 public:
  inline P_S_NOTIFY_MONSTER_MAP_REGISTER() : P_S_NOTIFY_MONSTER_MAP_REGISTER(nullptr) {}
  ~P_S_NOTIFY_MONSTER_MAP_REGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_MONSTER_MAP_REGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_MONSTER_MAP_REGISTER(const P_S_NOTIFY_MONSTER_MAP_REGISTER& from);
  P_S_NOTIFY_MONSTER_MAP_REGISTER(P_S_NOTIFY_MONSTER_MAP_REGISTER&& from) noexcept
    : P_S_NOTIFY_MONSTER_MAP_REGISTER() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_MONSTER_MAP_REGISTER& operator=(const P_S_NOTIFY_MONSTER_MAP_REGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_MONSTER_MAP_REGISTER& operator=(P_S_NOTIFY_MONSTER_MAP_REGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_MONSTER_MAP_REGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_MONSTER_MAP_REGISTER* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_MONSTER_MAP_REGISTER*>(
               &_P_S_NOTIFY_MONSTER_MAP_REGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(P_S_NOTIFY_MONSTER_MAP_REGISTER& a, P_S_NOTIFY_MONSTER_MAP_REGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_MONSTER_MAP_REGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_MONSTER_MAP_REGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_MONSTER_MAP_REGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_MONSTER_MAP_REGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_MONSTER_MAP_REGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_MONSTER_MAP_REGISTER& from) {
    P_S_NOTIFY_MONSTER_MAP_REGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_MONSTER_MAP_REGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_MONSTER_MAP_REGISTER";
  }
  protected:
  explicit P_S_NOTIFY_MONSTER_MAP_REGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMapIDFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_MONSTER_MAP_UNREGISTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER) */ {
 public:
  inline P_S_NOTIFY_MONSTER_MAP_UNREGISTER() : P_S_NOTIFY_MONSTER_MAP_UNREGISTER(nullptr) {}
  ~P_S_NOTIFY_MONSTER_MAP_UNREGISTER() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_MONSTER_MAP_UNREGISTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_MONSTER_MAP_UNREGISTER(const P_S_NOTIFY_MONSTER_MAP_UNREGISTER& from);
  P_S_NOTIFY_MONSTER_MAP_UNREGISTER(P_S_NOTIFY_MONSTER_MAP_UNREGISTER&& from) noexcept
    : P_S_NOTIFY_MONSTER_MAP_UNREGISTER() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_MONSTER_MAP_UNREGISTER& operator=(const P_S_NOTIFY_MONSTER_MAP_UNREGISTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_MONSTER_MAP_UNREGISTER& operator=(P_S_NOTIFY_MONSTER_MAP_UNREGISTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_MONSTER_MAP_UNREGISTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_MONSTER_MAP_UNREGISTER* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_MONSTER_MAP_UNREGISTER*>(
               &_P_S_NOTIFY_MONSTER_MAP_UNREGISTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(P_S_NOTIFY_MONSTER_MAP_UNREGISTER& a, P_S_NOTIFY_MONSTER_MAP_UNREGISTER& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_MONSTER_MAP_UNREGISTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_MONSTER_MAP_UNREGISTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_MONSTER_MAP_UNREGISTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_MONSTER_MAP_UNREGISTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_MONSTER_MAP_UNREGISTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_MONSTER_MAP_UNREGISTER& from) {
    P_S_NOTIFY_MONSTER_MAP_UNREGISTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_MONSTER_MAP_UNREGISTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER";
  }
  protected:
  explicit P_S_NOTIFY_MONSTER_MAP_UNREGISTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMapIDFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_ATTACK_ANI_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_ATTACK_ANI_EVENT) */ {
 public:
  inline P_S_NOTIFY_ATTACK_ANI_EVENT() : P_S_NOTIFY_ATTACK_ANI_EVENT(nullptr) {}
  ~P_S_NOTIFY_ATTACK_ANI_EVENT() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_ATTACK_ANI_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_ATTACK_ANI_EVENT(const P_S_NOTIFY_ATTACK_ANI_EVENT& from);
  P_S_NOTIFY_ATTACK_ANI_EVENT(P_S_NOTIFY_ATTACK_ANI_EVENT&& from) noexcept
    : P_S_NOTIFY_ATTACK_ANI_EVENT() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_ATTACK_ANI_EVENT& operator=(const P_S_NOTIFY_ATTACK_ANI_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_ATTACK_ANI_EVENT& operator=(P_S_NOTIFY_ATTACK_ANI_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_ATTACK_ANI_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_ATTACK_ANI_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_ATTACK_ANI_EVENT*>(
               &_P_S_NOTIFY_ATTACK_ANI_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(P_S_NOTIFY_ATTACK_ANI_EVENT& a, P_S_NOTIFY_ATTACK_ANI_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_ATTACK_ANI_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_ATTACK_ANI_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_ATTACK_ANI_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_ATTACK_ANI_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_ATTACK_ANI_EVENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_ATTACK_ANI_EVENT& from) {
    P_S_NOTIFY_ATTACK_ANI_EVENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_ATTACK_ANI_EVENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_ATTACK_ANI_EVENT";
  }
  protected:
  explicit P_S_NOTIFY_ATTACK_ANI_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 4,
    kMapIDFieldNumber = 1,
    kDirFieldNumber = 2,
    kAnimationCountFieldNumber = 3,
  };
  // string player = 4;
  void clear_player();
  const std::string& player() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player();
  PROTOBUF_NODISCARD std::string* release_player();
  void set_allocated_player(std::string* player);
  private:
  const std::string& _internal_player() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player(const std::string& value);
  std::string* _internal_mutable_player();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // int32 dir = 2;
  void clear_dir();
  int32_t dir() const;
  void set_dir(int32_t value);
  private:
  int32_t _internal_dir() const;
  void _internal_set_dir(int32_t value);
  public:

  // int32 animationCount = 3;
  void clear_animationcount();
  int32_t animationcount() const;
  void set_animationcount(int32_t value);
  private:
  int32_t _internal_animationcount() const;
  void _internal_set_animationcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_ATTACK_ANI_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_;
    int32_t mapid_;
    int32_t dir_;
    int32_t animationcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_CHARACTER_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_CHARACTER_INFO) */ {
 public:
  inline P_S_NOTIFY_CHARACTER_INFO() : P_S_NOTIFY_CHARACTER_INFO(nullptr) {}
  ~P_S_NOTIFY_CHARACTER_INFO() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_CHARACTER_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_CHARACTER_INFO(const P_S_NOTIFY_CHARACTER_INFO& from);
  P_S_NOTIFY_CHARACTER_INFO(P_S_NOTIFY_CHARACTER_INFO&& from) noexcept
    : P_S_NOTIFY_CHARACTER_INFO() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_CHARACTER_INFO& operator=(const P_S_NOTIFY_CHARACTER_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_CHARACTER_INFO& operator=(P_S_NOTIFY_CHARACTER_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_CHARACTER_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_CHARACTER_INFO* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_CHARACTER_INFO*>(
               &_P_S_NOTIFY_CHARACTER_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(P_S_NOTIFY_CHARACTER_INFO& a, P_S_NOTIFY_CHARACTER_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_CHARACTER_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_CHARACTER_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_CHARACTER_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_CHARACTER_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_CHARACTER_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_CHARACTER_INFO& from) {
    P_S_NOTIFY_CHARACTER_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_CHARACTER_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_CHARACTER_INFO";
  }
  protected:
  explicit P_S_NOTIFY_CHARACTER_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_CHARACTER_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA) */ {
 public:
  inline P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA() : P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA(nullptr) {}
  ~P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA(const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& from);
  P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA(P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA&& from) noexcept
    : P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& operator=(const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& operator=(P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA*>(
               &_P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& a, P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& from) {
    P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA";
  }
  protected:
  explicit P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kHpFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // float pos_x = 2;
  void clear_pos_x();
  float pos_x() const;
  void set_pos_x(float value);
  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);
  public:

  // float pos_y = 3;
  void clear_pos_y();
  float pos_y() const;
  void set_pos_y(float value);
  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);
  public:

  // int32 hp = 4;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    float pos_x_;
    float pos_y_;
    int32_t hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_MONSTER_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_MONSTER_INFO) */ {
 public:
  inline P_S_NOTIFY_MONSTER_INFO() : P_S_NOTIFY_MONSTER_INFO(nullptr) {}
  ~P_S_NOTIFY_MONSTER_INFO() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_MONSTER_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_MONSTER_INFO(const P_S_NOTIFY_MONSTER_INFO& from);
  P_S_NOTIFY_MONSTER_INFO(P_S_NOTIFY_MONSTER_INFO&& from) noexcept
    : P_S_NOTIFY_MONSTER_INFO() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_MONSTER_INFO& operator=(const P_S_NOTIFY_MONSTER_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_MONSTER_INFO& operator=(P_S_NOTIFY_MONSTER_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_MONSTER_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_MONSTER_INFO* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_MONSTER_INFO*>(
               &_P_S_NOTIFY_MONSTER_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(P_S_NOTIFY_MONSTER_INFO& a, P_S_NOTIFY_MONSTER_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_MONSTER_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_MONSTER_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_MONSTER_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_MONSTER_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_MONSTER_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_MONSTER_INFO& from) {
    P_S_NOTIFY_MONSTER_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_MONSTER_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_MONSTER_INFO";
  }
  protected:
  explicit P_S_NOTIFY_MONSTER_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA MONSTER_DATA;

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterDatasFieldNumber = 3,
    kMsgFieldNumber = 2,
    kMonsterCodeFieldNumber = 1,
  };
  // repeated .neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA monsterDatas = 3;
  int monsterdatas_size() const;
  private:
  int _internal_monsterdatas_size() const;
  public:
  void clear_monsterdatas();
  ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* mutable_monsterdatas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA >*
      mutable_monsterdatas();
  private:
  const ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& _internal_monsterdatas(int index) const;
  ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* _internal_add_monsterdatas();
  public:
  const ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& monsterdatas(int index) const;
  ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* add_monsterdatas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA >&
      monsterdatas() const;

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 monsterCode = 1;
  void clear_monstercode();
  int32_t monstercode() const;
  void set_monstercode(int32_t value);
  private:
  int32_t _internal_monstercode() const;
  void _internal_set_monstercode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_MONSTER_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA > monsterdatas_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t monstercode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_ATTACK_RANGE_HIT_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT) */ {
 public:
  inline P_C_REQ_ATTACK_RANGE_HIT_EVENT() : P_C_REQ_ATTACK_RANGE_HIT_EVENT(nullptr) {}
  ~P_C_REQ_ATTACK_RANGE_HIT_EVENT() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_ATTACK_RANGE_HIT_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_ATTACK_RANGE_HIT_EVENT(const P_C_REQ_ATTACK_RANGE_HIT_EVENT& from);
  P_C_REQ_ATTACK_RANGE_HIT_EVENT(P_C_REQ_ATTACK_RANGE_HIT_EVENT&& from) noexcept
    : P_C_REQ_ATTACK_RANGE_HIT_EVENT() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_ATTACK_RANGE_HIT_EVENT& operator=(const P_C_REQ_ATTACK_RANGE_HIT_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_ATTACK_RANGE_HIT_EVENT& operator=(P_C_REQ_ATTACK_RANGE_HIT_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_ATTACK_RANGE_HIT_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_ATTACK_RANGE_HIT_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_ATTACK_RANGE_HIT_EVENT*>(
               &_P_C_REQ_ATTACK_RANGE_HIT_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(P_C_REQ_ATTACK_RANGE_HIT_EVENT& a, P_C_REQ_ATTACK_RANGE_HIT_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_ATTACK_RANGE_HIT_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_ATTACK_RANGE_HIT_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_ATTACK_RANGE_HIT_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_ATTACK_RANGE_HIT_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_ATTACK_RANGE_HIT_EVENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_ATTACK_RANGE_HIT_EVENT& from) {
    P_C_REQ_ATTACK_RANGE_HIT_EVENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_ATTACK_RANGE_HIT_EVENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT";
  }
  protected:
  explicit P_C_REQ_ATTACK_RANGE_HIT_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackUserFieldNumber = 2,
    kHitObjectFieldNumber = 3,
    kMapIDFieldNumber = 1,
    kDamageFieldNumber = 4,
  };
  // string attackUser = 2;
  void clear_attackuser();
  const std::string& attackuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attackuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attackuser();
  PROTOBUF_NODISCARD std::string* release_attackuser();
  void set_allocated_attackuser(std::string* attackuser);
  private:
  const std::string& _internal_attackuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attackuser(const std::string& value);
  std::string* _internal_mutable_attackuser();
  public:

  // string hitObject = 3;
  void clear_hitobject();
  const std::string& hitobject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hitobject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hitobject();
  PROTOBUF_NODISCARD std::string* release_hitobject();
  void set_allocated_hitobject(std::string* hitobject);
  private:
  const std::string& _internal_hitobject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hitobject(const std::string& value);
  std::string* _internal_mutable_hitobject();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // int32 damage = 4;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attackuser_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hitobject_;
    int32_t mapid_;
    int32_t damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_EFFECT_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_EFFECT_EVENT) */ {
 public:
  inline P_S_NOTIFY_EFFECT_EVENT() : P_S_NOTIFY_EFFECT_EVENT(nullptr) {}
  ~P_S_NOTIFY_EFFECT_EVENT() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_EFFECT_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_EFFECT_EVENT(const P_S_NOTIFY_EFFECT_EVENT& from);
  P_S_NOTIFY_EFFECT_EVENT(P_S_NOTIFY_EFFECT_EVENT&& from) noexcept
    : P_S_NOTIFY_EFFECT_EVENT() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_EFFECT_EVENT& operator=(const P_S_NOTIFY_EFFECT_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_EFFECT_EVENT& operator=(P_S_NOTIFY_EFFECT_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_EFFECT_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_EFFECT_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_EFFECT_EVENT*>(
               &_P_S_NOTIFY_EFFECT_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(P_S_NOTIFY_EFFECT_EVENT& a, P_S_NOTIFY_EFFECT_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_EFFECT_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_EFFECT_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_EFFECT_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_EFFECT_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_EFFECT_EVENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_EFFECT_EVENT& from) {
    P_S_NOTIFY_EFFECT_EVENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_EFFECT_EVENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_EFFECT_EVENT";
  }
  protected:
  explicit P_S_NOTIFY_EFFECT_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackUserFieldNumber = 4,
    kStartPosXFieldNumber = 1,
    kStartPosYFieldNumber = 2,
    kStartPosZFieldNumber = 3,
    kDisFieldNumber = 5,
    kDirFieldNumber = 6,
  };
  // string attackUser = 4;
  void clear_attackuser();
  const std::string& attackuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attackuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attackuser();
  PROTOBUF_NODISCARD std::string* release_attackuser();
  void set_allocated_attackuser(std::string* attackuser);
  private:
  const std::string& _internal_attackuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attackuser(const std::string& value);
  std::string* _internal_mutable_attackuser();
  public:

  // float startPos_x = 1;
  void clear_startpos_x();
  float startpos_x() const;
  void set_startpos_x(float value);
  private:
  float _internal_startpos_x() const;
  void _internal_set_startpos_x(float value);
  public:

  // float startPos_y = 2;
  void clear_startpos_y();
  float startpos_y() const;
  void set_startpos_y(float value);
  private:
  float _internal_startpos_y() const;
  void _internal_set_startpos_y(float value);
  public:

  // float startPos_z = 3;
  void clear_startpos_z();
  float startpos_z() const;
  void set_startpos_z(float value);
  private:
  float _internal_startpos_z() const;
  void _internal_set_startpos_z(float value);
  public:

  // float dis = 5;
  void clear_dis();
  float dis() const;
  void set_dis(float value);
  private:
  float _internal_dis() const;
  void _internal_set_dis(float value);
  public:

  // int32 dir = 6;
  void clear_dir();
  int32_t dir() const;
  void set_dir(int32_t value);
  private:
  int32_t _internal_dir() const;
  void _internal_set_dir(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_EFFECT_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attackuser_;
    float startpos_x_;
    float startpos_y_;
    float startpos_z_;
    float dis_;
    int32_t dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_ATTACK_RANGE_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_ATTACK_RANGE_EVENT) */ {
 public:
  inline P_C_REQ_ATTACK_RANGE_EVENT() : P_C_REQ_ATTACK_RANGE_EVENT(nullptr) {}
  ~P_C_REQ_ATTACK_RANGE_EVENT() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_ATTACK_RANGE_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_ATTACK_RANGE_EVENT(const P_C_REQ_ATTACK_RANGE_EVENT& from);
  P_C_REQ_ATTACK_RANGE_EVENT(P_C_REQ_ATTACK_RANGE_EVENT&& from) noexcept
    : P_C_REQ_ATTACK_RANGE_EVENT() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_ATTACK_RANGE_EVENT& operator=(const P_C_REQ_ATTACK_RANGE_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_ATTACK_RANGE_EVENT& operator=(P_C_REQ_ATTACK_RANGE_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_ATTACK_RANGE_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_ATTACK_RANGE_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_ATTACK_RANGE_EVENT*>(
               &_P_C_REQ_ATTACK_RANGE_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(P_C_REQ_ATTACK_RANGE_EVENT& a, P_C_REQ_ATTACK_RANGE_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_ATTACK_RANGE_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_ATTACK_RANGE_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_ATTACK_RANGE_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_ATTACK_RANGE_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_ATTACK_RANGE_EVENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_ATTACK_RANGE_EVENT& from) {
    P_C_REQ_ATTACK_RANGE_EVENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_ATTACK_RANGE_EVENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_ATTACK_RANGE_EVENT";
  }
  protected:
  explicit P_C_REQ_ATTACK_RANGE_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackUserFieldNumber = 6,
    kStartPosXFieldNumber = 1,
    kStartPosYFieldNumber = 2,
    kStartPosZFieldNumber = 3,
    kMapIDFieldNumber = 4,
    kDirFieldNumber = 5,
    kDisFieldNumber = 7,
    kDamageFieldNumber = 8,
    kAnimationFieldNumber = 9,
  };
  // string attackUser = 6;
  void clear_attackuser();
  const std::string& attackuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attackuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attackuser();
  PROTOBUF_NODISCARD std::string* release_attackuser();
  void set_allocated_attackuser(std::string* attackuser);
  private:
  const std::string& _internal_attackuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attackuser(const std::string& value);
  std::string* _internal_mutable_attackuser();
  public:

  // float startPos_x = 1;
  void clear_startpos_x();
  float startpos_x() const;
  void set_startpos_x(float value);
  private:
  float _internal_startpos_x() const;
  void _internal_set_startpos_x(float value);
  public:

  // float startPos_y = 2;
  void clear_startpos_y();
  float startpos_y() const;
  void set_startpos_y(float value);
  private:
  float _internal_startpos_y() const;
  void _internal_set_startpos_y(float value);
  public:

  // float startPos_z = 3;
  void clear_startpos_z();
  float startpos_z() const;
  void set_startpos_z(float value);
  private:
  float _internal_startpos_z() const;
  void _internal_set_startpos_z(float value);
  public:

  // int32 mapID = 4;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // int32 dir = 5;
  void clear_dir();
  int32_t dir() const;
  void set_dir(int32_t value);
  private:
  int32_t _internal_dir() const;
  void _internal_set_dir(int32_t value);
  public:

  // float dis = 7;
  void clear_dis();
  float dis() const;
  void set_dis(float value);
  private:
  float _internal_dis() const;
  void _internal_set_dis(float value);
  public:

  // int32 damage = 8;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // int32 animation = 9;
  void clear_animation();
  int32_t animation() const;
  void set_animation(int32_t value);
  private:
  int32_t _internal_animation() const;
  void _internal_set_animation(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_ATTACK_RANGE_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attackuser_;
    float startpos_x_;
    float startpos_y_;
    float startpos_z_;
    int32_t mapid_;
    int32_t dir_;
    float dis_;
    int32_t damage_;
    int32_t animation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_REQ_ATTACK_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_REQ_ATTACK_EVENT) */ {
 public:
  inline P_C_REQ_ATTACK_EVENT() : P_C_REQ_ATTACK_EVENT(nullptr) {}
  ~P_C_REQ_ATTACK_EVENT() override;
  explicit PROTOBUF_CONSTEXPR P_C_REQ_ATTACK_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_REQ_ATTACK_EVENT(const P_C_REQ_ATTACK_EVENT& from);
  P_C_REQ_ATTACK_EVENT(P_C_REQ_ATTACK_EVENT&& from) noexcept
    : P_C_REQ_ATTACK_EVENT() {
    *this = ::std::move(from);
  }

  inline P_C_REQ_ATTACK_EVENT& operator=(const P_C_REQ_ATTACK_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_REQ_ATTACK_EVENT& operator=(P_C_REQ_ATTACK_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_REQ_ATTACK_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_REQ_ATTACK_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_C_REQ_ATTACK_EVENT*>(
               &_P_C_REQ_ATTACK_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(P_C_REQ_ATTACK_EVENT& a, P_C_REQ_ATTACK_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_REQ_ATTACK_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_REQ_ATTACK_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_REQ_ATTACK_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_REQ_ATTACK_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_REQ_ATTACK_EVENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_REQ_ATTACK_EVENT& from) {
    P_C_REQ_ATTACK_EVENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_REQ_ATTACK_EVENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_REQ_ATTACK_EVENT";
  }
  protected:
  explicit P_C_REQ_ATTACK_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackUserFieldNumber = 2,
    kHitObjectFieldNumber = 3,
    kMapIDFieldNumber = 1,
    kDirFieldNumber = 4,
    kAnimationFieldNumber = 5,
    kDamageFieldNumber = 6,
  };
  // string attackUser = 2;
  void clear_attackuser();
  const std::string& attackuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attackuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attackuser();
  PROTOBUF_NODISCARD std::string* release_attackuser();
  void set_allocated_attackuser(std::string* attackuser);
  private:
  const std::string& _internal_attackuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attackuser(const std::string& value);
  std::string* _internal_mutable_attackuser();
  public:

  // string hitObject = 3;
  void clear_hitobject();
  const std::string& hitobject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hitobject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hitobject();
  PROTOBUF_NODISCARD std::string* release_hitobject();
  void set_allocated_hitobject(std::string* hitobject);
  private:
  const std::string& _internal_hitobject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hitobject(const std::string& value);
  std::string* _internal_mutable_hitobject();
  public:

  // int32 mapID = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // int32 dir = 4;
  void clear_dir();
  int32_t dir() const;
  void set_dir(int32_t value);
  private:
  int32_t _internal_dir() const;
  void _internal_set_dir(int32_t value);
  public:

  // int32 animation = 5;
  void clear_animation();
  int32_t animation() const;
  void set_animation(int32_t value);
  private:
  int32_t _internal_animation() const;
  void _internal_set_animation(int32_t value);
  public:

  // int32 damage = 6;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_REQ_ATTACK_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attackuser_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hitobject_;
    int32_t mapid_;
    int32_t dir_;
    int32_t animation_;
    int32_t damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_RES_ATTACK_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:neo.P_S_RES_ATTACK_EVENT) */ {
 public:
  inline P_S_RES_ATTACK_EVENT() : P_S_RES_ATTACK_EVENT(nullptr) {}
  explicit PROTOBUF_CONSTEXPR P_S_RES_ATTACK_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_RES_ATTACK_EVENT(const P_S_RES_ATTACK_EVENT& from);
  P_S_RES_ATTACK_EVENT(P_S_RES_ATTACK_EVENT&& from) noexcept
    : P_S_RES_ATTACK_EVENT() {
    *this = ::std::move(from);
  }

  inline P_S_RES_ATTACK_EVENT& operator=(const P_S_RES_ATTACK_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_RES_ATTACK_EVENT& operator=(P_S_RES_ATTACK_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_RES_ATTACK_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_RES_ATTACK_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_S_RES_ATTACK_EVENT*>(
               &_P_S_RES_ATTACK_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(P_S_RES_ATTACK_EVENT& a, P_S_RES_ATTACK_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_RES_ATTACK_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_RES_ATTACK_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_RES_ATTACK_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_RES_ATTACK_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const P_S_RES_ATTACK_EVENT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const P_S_RES_ATTACK_EVENT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_RES_ATTACK_EVENT";
  }
  protected:
  explicit P_S_RES_ATTACK_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:neo.P_S_RES_ATTACK_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_ATTACK_EVENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_ATTACK_EVENT) */ {
 public:
  inline P_S_NOTIFY_ATTACK_EVENT() : P_S_NOTIFY_ATTACK_EVENT(nullptr) {}
  ~P_S_NOTIFY_ATTACK_EVENT() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_ATTACK_EVENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_ATTACK_EVENT(const P_S_NOTIFY_ATTACK_EVENT& from);
  P_S_NOTIFY_ATTACK_EVENT(P_S_NOTIFY_ATTACK_EVENT&& from) noexcept
    : P_S_NOTIFY_ATTACK_EVENT() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_ATTACK_EVENT& operator=(const P_S_NOTIFY_ATTACK_EVENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_ATTACK_EVENT& operator=(P_S_NOTIFY_ATTACK_EVENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_ATTACK_EVENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_ATTACK_EVENT* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_ATTACK_EVENT*>(
               &_P_S_NOTIFY_ATTACK_EVENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(P_S_NOTIFY_ATTACK_EVENT& a, P_S_NOTIFY_ATTACK_EVENT& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_ATTACK_EVENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_ATTACK_EVENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_ATTACK_EVENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_ATTACK_EVENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_ATTACK_EVENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_ATTACK_EVENT& from) {
    P_S_NOTIFY_ATTACK_EVENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_ATTACK_EVENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_ATTACK_EVENT";
  }
  protected:
  explicit P_S_NOTIFY_ATTACK_EVENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitObjectFieldNumber = 1,
    kHPFieldNumber = 2,
  };
  // string hitObject = 1;
  void clear_hitobject();
  const std::string& hitobject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hitobject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hitobject();
  PROTOBUF_NODISCARD std::string* release_hitobject();
  void set_allocated_hitobject(std::string* hitobject);
  private:
  const std::string& _internal_hitobject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hitobject(const std::string& value);
  std::string* _internal_mutable_hitobject();
  public:

  // int32 HP = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_ATTACK_EVENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hitobject_;
    int32_t hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_C_NOTIFY_RESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_C_NOTIFY_RESPAWN) */ {
 public:
  inline P_C_NOTIFY_RESPAWN() : P_C_NOTIFY_RESPAWN(nullptr) {}
  ~P_C_NOTIFY_RESPAWN() override;
  explicit PROTOBUF_CONSTEXPR P_C_NOTIFY_RESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_C_NOTIFY_RESPAWN(const P_C_NOTIFY_RESPAWN& from);
  P_C_NOTIFY_RESPAWN(P_C_NOTIFY_RESPAWN&& from) noexcept
    : P_C_NOTIFY_RESPAWN() {
    *this = ::std::move(from);
  }

  inline P_C_NOTIFY_RESPAWN& operator=(const P_C_NOTIFY_RESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_C_NOTIFY_RESPAWN& operator=(P_C_NOTIFY_RESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_C_NOTIFY_RESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_C_NOTIFY_RESPAWN* internal_default_instance() {
    return reinterpret_cast<const P_C_NOTIFY_RESPAWN*>(
               &_P_C_NOTIFY_RESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(P_C_NOTIFY_RESPAWN& a, P_C_NOTIFY_RESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(P_C_NOTIFY_RESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_C_NOTIFY_RESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_C_NOTIFY_RESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_C_NOTIFY_RESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_C_NOTIFY_RESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_C_NOTIFY_RESPAWN& from) {
    P_C_NOTIFY_RESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_C_NOTIFY_RESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_C_NOTIFY_RESPAWN";
  }
  protected:
  explicit P_C_NOTIFY_RESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:neo.P_C_NOTIFY_RESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_NOTIFY_OBJECT_UPDATE final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:neo.P_NOTIFY_OBJECT_UPDATE) */ {
 public:
  inline P_NOTIFY_OBJECT_UPDATE() : P_NOTIFY_OBJECT_UPDATE(nullptr) {}
  explicit PROTOBUF_CONSTEXPR P_NOTIFY_OBJECT_UPDATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_NOTIFY_OBJECT_UPDATE(const P_NOTIFY_OBJECT_UPDATE& from);
  P_NOTIFY_OBJECT_UPDATE(P_NOTIFY_OBJECT_UPDATE&& from) noexcept
    : P_NOTIFY_OBJECT_UPDATE() {
    *this = ::std::move(from);
  }

  inline P_NOTIFY_OBJECT_UPDATE& operator=(const P_NOTIFY_OBJECT_UPDATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_NOTIFY_OBJECT_UPDATE& operator=(P_NOTIFY_OBJECT_UPDATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_NOTIFY_OBJECT_UPDATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_NOTIFY_OBJECT_UPDATE* internal_default_instance() {
    return reinterpret_cast<const P_NOTIFY_OBJECT_UPDATE*>(
               &_P_NOTIFY_OBJECT_UPDATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(P_NOTIFY_OBJECT_UPDATE& a, P_NOTIFY_OBJECT_UPDATE& b) {
    a.Swap(&b);
  }
  inline void Swap(P_NOTIFY_OBJECT_UPDATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_NOTIFY_OBJECT_UPDATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_NOTIFY_OBJECT_UPDATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_NOTIFY_OBJECT_UPDATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const P_NOTIFY_OBJECT_UPDATE& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const P_NOTIFY_OBJECT_UPDATE& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_NOTIFY_OBJECT_UPDATE";
  }
  protected:
  explicit P_NOTIFY_OBJECT_UPDATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:neo.P_NOTIFY_OBJECT_UPDATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA) */ {
 public:
  inline P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA() : P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA(nullptr) {}
  ~P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA(const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& from);
  P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA(P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA&& from) noexcept
    : P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& operator=(const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& operator=(P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA*>(
               &_P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& a, P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& from) {
    P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA";
  }
  protected:
  explicit P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUserCountFieldNumber = 2,
    kChannelIDFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 userCount = 2;
  void clear_usercount();
  int32_t usercount() const;
  void set_usercount(int32_t value);
  private:
  int32_t _internal_usercount() const;
  void _internal_set_usercount(int32_t value);
  public:

  // int32 channelID = 3;
  void clear_channelid();
  int32_t channelid() const;
  void set_channelid(int32_t value);
  private:
  int32_t _internal_channelid() const;
  void _internal_set_channelid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t usercount_;
    int32_t channelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// -------------------------------------------------------------------

class P_S_NOTIFY_CHANNEL_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:neo.P_S_NOTIFY_CHANNEL_INFO) */ {
 public:
  inline P_S_NOTIFY_CHANNEL_INFO() : P_S_NOTIFY_CHANNEL_INFO(nullptr) {}
  ~P_S_NOTIFY_CHANNEL_INFO() override;
  explicit PROTOBUF_CONSTEXPR P_S_NOTIFY_CHANNEL_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_S_NOTIFY_CHANNEL_INFO(const P_S_NOTIFY_CHANNEL_INFO& from);
  P_S_NOTIFY_CHANNEL_INFO(P_S_NOTIFY_CHANNEL_INFO&& from) noexcept
    : P_S_NOTIFY_CHANNEL_INFO() {
    *this = ::std::move(from);
  }

  inline P_S_NOTIFY_CHANNEL_INFO& operator=(const P_S_NOTIFY_CHANNEL_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_S_NOTIFY_CHANNEL_INFO& operator=(P_S_NOTIFY_CHANNEL_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_S_NOTIFY_CHANNEL_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_S_NOTIFY_CHANNEL_INFO* internal_default_instance() {
    return reinterpret_cast<const P_S_NOTIFY_CHANNEL_INFO*>(
               &_P_S_NOTIFY_CHANNEL_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(P_S_NOTIFY_CHANNEL_INFO& a, P_S_NOTIFY_CHANNEL_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(P_S_NOTIFY_CHANNEL_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_S_NOTIFY_CHANNEL_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_S_NOTIFY_CHANNEL_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_S_NOTIFY_CHANNEL_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_S_NOTIFY_CHANNEL_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_S_NOTIFY_CHANNEL_INFO& from) {
    P_S_NOTIFY_CHANNEL_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_S_NOTIFY_CHANNEL_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neo.P_S_NOTIFY_CHANNEL_INFO";
  }
  protected:
  explicit P_S_NOTIFY_CHANNEL_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA CHANNEL_DATA;

  // accessors -------------------------------------------------------

  enum : int {
    kChaanelInfosFieldNumber = 1,
  };
  // repeated .neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA chaanelInfos = 1;
  int chaanelinfos_size() const;
  private:
  int _internal_chaanelinfos_size() const;
  public:
  void clear_chaanelinfos();
  ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* mutable_chaanelinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA >*
      mutable_chaanelinfos();
  private:
  const ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& _internal_chaanelinfos(int index) const;
  ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* _internal_add_chaanelinfos();
  public:
  const ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& chaanelinfos(int index) const;
  ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* add_chaanelinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA >&
      chaanelinfos() const;

  // @@protoc_insertion_point(class_scope:neo.P_S_NOTIFY_CHANNEL_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA > chaanelinfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// .neo.PacketID id = 1;
inline void Header::clear_id() {
  _impl_.id_ = 0;
}
inline ::neo::PacketID Header::_internal_id() const {
  return static_cast< ::neo::PacketID >(_impl_.id_);
}
inline ::neo::PacketID Header::id() const {
  // @@protoc_insertion_point(field_get:neo.Header.id)
  return _internal_id();
}
inline void Header::_internal_set_id(::neo::PacketID value) {
  
  _impl_.id_ = value;
}
inline void Header::set_id(::neo::PacketID value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:neo.Header.id)
}

// int32 size = 2;
inline void Header::clear_size() {
  _impl_.size_ = 0;
}
inline int32_t Header::_internal_size() const {
  return _impl_.size_;
}
inline int32_t Header::size() const {
  // @@protoc_insertion_point(field_get:neo.Header.size)
  return _internal_size();
}
inline void Header::_internal_set_size(int32_t value) {
  
  _impl_.size_ = value;
}
inline void Header::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:neo.Header.size)
}

// -------------------------------------------------------------------

// P_C_REQ_LOGIN

// string id = 1;
inline void P_C_REQ_LOGIN::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& P_C_REQ_LOGIN::id() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_LOGIN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_LOGIN::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_LOGIN.id)
}
inline std::string* P_C_REQ_LOGIN::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_LOGIN.id)
  return _s;
}
inline const std::string& P_C_REQ_LOGIN::_internal_id() const {
  return _impl_.id_.Get();
}
inline void P_C_REQ_LOGIN::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_LOGIN::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_LOGIN::release_id() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_LOGIN.id)
  return _impl_.id_.Release();
}
inline void P_C_REQ_LOGIN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_LOGIN.id)
}

// bytes uuid = 2;
inline void P_C_REQ_LOGIN::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& P_C_REQ_LOGIN::uuid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_LOGIN.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_LOGIN::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_LOGIN.uuid)
}
inline std::string* P_C_REQ_LOGIN::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_LOGIN.uuid)
  return _s;
}
inline const std::string& P_C_REQ_LOGIN::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void P_C_REQ_LOGIN::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_LOGIN::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_LOGIN::release_uuid() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_LOGIN.uuid)
  return _impl_.uuid_.Release();
}
inline void P_C_REQ_LOGIN::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_LOGIN.uuid)
}

// -------------------------------------------------------------------

// P_S_RES_LOGOUT

// string user = 1;
inline void P_S_RES_LOGOUT::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& P_S_RES_LOGOUT::user() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_LOGOUT.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_RES_LOGOUT::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_RES_LOGOUT.user)
}
inline std::string* P_S_RES_LOGOUT::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:neo.P_S_RES_LOGOUT.user)
  return _s;
}
inline const std::string& P_S_RES_LOGOUT::_internal_user() const {
  return _impl_.user_.Get();
}
inline void P_S_RES_LOGOUT::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_RES_LOGOUT::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_RES_LOGOUT::release_user() {
  // @@protoc_insertion_point(field_release:neo.P_S_RES_LOGOUT.user)
  return _impl_.user_.Release();
}
inline void P_S_RES_LOGOUT::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_RES_LOGOUT.user)
}

// -------------------------------------------------------------------

// P_C_REQ_LOGOUT

// int32 mapID = 1;
inline void P_C_REQ_LOGOUT::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_C_REQ_LOGOUT::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_C_REQ_LOGOUT::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_LOGOUT.mapID)
  return _internal_mapid();
}
inline void P_C_REQ_LOGOUT::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_C_REQ_LOGOUT::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_LOGOUT.mapID)
}

// string user = 2;
inline void P_C_REQ_LOGOUT::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& P_C_REQ_LOGOUT::user() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_LOGOUT.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_LOGOUT::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_LOGOUT.user)
}
inline std::string* P_C_REQ_LOGOUT::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_LOGOUT.user)
  return _s;
}
inline const std::string& P_C_REQ_LOGOUT::_internal_user() const {
  return _impl_.user_.Get();
}
inline void P_C_REQ_LOGOUT::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_LOGOUT::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_LOGOUT::release_user() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_LOGOUT.user)
  return _impl_.user_.Release();
}
inline void P_C_REQ_LOGOUT::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_LOGOUT.user)
}

// -------------------------------------------------------------------

// P_S_RES_LOGIN

// .neo.PacketResult result = 1;
inline void P_S_RES_LOGIN::clear_result() {
  _impl_.result_ = 0;
}
inline ::neo::PacketResult P_S_RES_LOGIN::_internal_result() const {
  return static_cast< ::neo::PacketResult >(_impl_.result_);
}
inline ::neo::PacketResult P_S_RES_LOGIN::result() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_LOGIN.result)
  return _internal_result();
}
inline void P_S_RES_LOGIN::_internal_set_result(::neo::PacketResult value) {
  
  _impl_.result_ = value;
}
inline void P_S_RES_LOGIN::set_result(::neo::PacketResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:neo.P_S_RES_LOGIN.result)
}

// string msg = 2;
inline void P_S_RES_LOGIN::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& P_S_RES_LOGIN::msg() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_LOGIN.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_RES_LOGIN::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_RES_LOGIN.msg)
}
inline std::string* P_S_RES_LOGIN::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:neo.P_S_RES_LOGIN.msg)
  return _s;
}
inline const std::string& P_S_RES_LOGIN::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void P_S_RES_LOGIN::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_RES_LOGIN::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_RES_LOGIN::release_msg() {
  // @@protoc_insertion_point(field_release:neo.P_S_RES_LOGIN.msg)
  return _impl_.msg_.Release();
}
inline void P_S_RES_LOGIN::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_RES_LOGIN.msg)
}

// -------------------------------------------------------------------

// P_C_NOTIFY_PING

// int64 time = 1;
inline void P_C_NOTIFY_PING::clear_time() {
  _impl_.time_ = int64_t{0};
}
inline int64_t P_C_NOTIFY_PING::_internal_time() const {
  return _impl_.time_;
}
inline int64_t P_C_NOTIFY_PING::time() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_PING.time)
  return _internal_time();
}
inline void P_C_NOTIFY_PING::_internal_set_time(int64_t value) {
  
  _impl_.time_ = value;
}
inline void P_C_NOTIFY_PING::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_PING.time)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_PING

// int64 time = 1;
inline void P_S_NOTIFY_PING::clear_time() {
  _impl_.time_ = int64_t{0};
}
inline int64_t P_S_NOTIFY_PING::_internal_time() const {
  return _impl_.time_;
}
inline int64_t P_S_NOTIFY_PING::time() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_PING.time)
  return _internal_time();
}
inline void P_S_NOTIFY_PING::_internal_set_time(int64_t value) {
  
  _impl_.time_ = value;
}
inline void P_S_NOTIFY_PING::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_PING.time)
}

// -------------------------------------------------------------------

// P_C_UPDATE_CHAR_POSITION

// string id = 1;
inline void P_C_UPDATE_CHAR_POSITION::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& P_C_UPDATE_CHAR_POSITION::id() const {
  // @@protoc_insertion_point(field_get:neo.P_C_UPDATE_CHAR_POSITION.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_UPDATE_CHAR_POSITION::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_UPDATE_CHAR_POSITION.id)
}
inline std::string* P_C_UPDATE_CHAR_POSITION::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:neo.P_C_UPDATE_CHAR_POSITION.id)
  return _s;
}
inline const std::string& P_C_UPDATE_CHAR_POSITION::_internal_id() const {
  return _impl_.id_.Get();
}
inline void P_C_UPDATE_CHAR_POSITION::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_UPDATE_CHAR_POSITION::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_UPDATE_CHAR_POSITION::release_id() {
  // @@protoc_insertion_point(field_release:neo.P_C_UPDATE_CHAR_POSITION.id)
  return _impl_.id_.Release();
}
inline void P_C_UPDATE_CHAR_POSITION::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_UPDATE_CHAR_POSITION.id)
}

// -------------------------------------------------------------------

// GAME_OBJECT

// string name = 1;
inline void GAME_OBJECT::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GAME_OBJECT::name() const {
  // @@protoc_insertion_point(field_get:neo.GAME_OBJECT.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GAME_OBJECT::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.GAME_OBJECT.name)
}
inline std::string* GAME_OBJECT::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.GAME_OBJECT.name)
  return _s;
}
inline const std::string& GAME_OBJECT::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GAME_OBJECT::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GAME_OBJECT::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GAME_OBJECT::release_name() {
  // @@protoc_insertion_point(field_release:neo.GAME_OBJECT.name)
  return _impl_.name_.Release();
}
inline void GAME_OBJECT::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.GAME_OBJECT.name)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION

// bytes object_id = 1;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_object_id() {
  _impl_.object_id_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::object_id() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.object_id)
  return _internal_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_object_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.object_id)
}
inline std::string* P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::mutable_object_id() {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.object_id)
  return _s;
}
inline const std::string& P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_object_id() const {
  return _impl_.object_id_.Get();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_object_id(const std::string& value) {
  
  _impl_.object_id_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_mutable_object_id() {
  
  return _impl_.object_id_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::release_object_id() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.object_id)
  return _impl_.object_id_.Release();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_allocated_object_id(std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  _impl_.object_id_.SetAllocated(object_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_id_.IsDefault()) {
    _impl_.object_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.object_id)
}

// float x = 2;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_x() {
  _impl_.x_ = 0;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_x() const {
  return _impl_.x_;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::x() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.x)
  return _internal_x();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.x)
}

// float y = 3;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_y() {
  _impl_.y_ = 0;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_y() const {
  return _impl_.y_;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::y() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.y)
  return _internal_y();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.y)
}

// float z = 4;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_z() {
  _impl_.z_ = 0;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_z() const {
  return _impl_.z_;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::z() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.z)
  return _internal_z();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.z)
}

// float voleoctiy_x = 5;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_voleoctiy_x() {
  _impl_.voleoctiy_x_ = 0;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_voleoctiy_x() const {
  return _impl_.voleoctiy_x_;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::voleoctiy_x() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.voleoctiy_x)
  return _internal_voleoctiy_x();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_voleoctiy_x(float value) {
  
  _impl_.voleoctiy_x_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_voleoctiy_x(float value) {
  _internal_set_voleoctiy_x(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.voleoctiy_x)
}

// float voleoctiy_y = 6;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_voleoctiy_y() {
  _impl_.voleoctiy_y_ = 0;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_voleoctiy_y() const {
  return _impl_.voleoctiy_y_;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::voleoctiy_y() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.voleoctiy_y)
  return _internal_voleoctiy_y();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_voleoctiy_y(float value) {
  
  _impl_.voleoctiy_y_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_voleoctiy_y(float value) {
  _internal_set_voleoctiy_y(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.voleoctiy_y)
}

// float speed = 7;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_speed() {
  _impl_.speed_ = 0;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_speed() const {
  return _impl_.speed_;
}
inline float P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::speed() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.speed)
  return _internal_speed();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.speed)
}

// int32 animation = 8;
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::clear_animation() {
  _impl_.animation_ = 0;
}
inline int32_t P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_animation() const {
  return _impl_.animation_;
}
inline int32_t P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::animation() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.animation)
  return _internal_animation();
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::_internal_set_animation(int32_t value) {
  
  _impl_.animation_ = value;
}
inline void P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION::set_animation(int32_t value) {
  _internal_set_animation(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION.animation)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_MONSTER_POSITION

// repeated .neo.P_S_NOTIFY_MONSTER_POSITION.MONSTER_POSITION monster_position = 1;
inline int P_S_NOTIFY_MONSTER_POSITION::_internal_monster_position_size() const {
  return _impl_.monster_position_.size();
}
inline int P_S_NOTIFY_MONSTER_POSITION::monster_position_size() const {
  return _internal_monster_position_size();
}
inline void P_S_NOTIFY_MONSTER_POSITION::clear_monster_position() {
  _impl_.monster_position_.Clear();
}
inline ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* P_S_NOTIFY_MONSTER_POSITION::mutable_monster_position(int index) {
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_POSITION.monster_position)
  return _impl_.monster_position_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION >*
P_S_NOTIFY_MONSTER_POSITION::mutable_monster_position() {
  // @@protoc_insertion_point(field_mutable_list:neo.P_S_NOTIFY_MONSTER_POSITION.monster_position)
  return &_impl_.monster_position_;
}
inline const ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& P_S_NOTIFY_MONSTER_POSITION::_internal_monster_position(int index) const {
  return _impl_.monster_position_.Get(index);
}
inline const ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION& P_S_NOTIFY_MONSTER_POSITION::monster_position(int index) const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_POSITION.monster_position)
  return _internal_monster_position(index);
}
inline ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* P_S_NOTIFY_MONSTER_POSITION::_internal_add_monster_position() {
  return _impl_.monster_position_.Add();
}
inline ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* P_S_NOTIFY_MONSTER_POSITION::add_monster_position() {
  ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION* _add = _internal_add_monster_position();
  // @@protoc_insertion_point(field_add:neo.P_S_NOTIFY_MONSTER_POSITION.monster_position)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_POSITION_MONSTER_POSITION >&
P_S_NOTIFY_MONSTER_POSITION::monster_position() const {
  // @@protoc_insertion_point(field_list:neo.P_S_NOTIFY_MONSTER_POSITION.monster_position)
  return _impl_.monster_position_;
}

// -------------------------------------------------------------------

// P_C_REQ_CHANNEL_REGISTER

// string user = 1;
inline void P_C_REQ_CHANNEL_REGISTER::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& P_C_REQ_CHANNEL_REGISTER::user() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHANNEL_REGISTER.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_CHANNEL_REGISTER::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHANNEL_REGISTER.user)
}
inline std::string* P_C_REQ_CHANNEL_REGISTER::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_CHANNEL_REGISTER.user)
  return _s;
}
inline const std::string& P_C_REQ_CHANNEL_REGISTER::_internal_user() const {
  return _impl_.user_.Get();
}
inline void P_C_REQ_CHANNEL_REGISTER::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_CHANNEL_REGISTER::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_CHANNEL_REGISTER::release_user() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_CHANNEL_REGISTER.user)
  return _impl_.user_.Release();
}
inline void P_C_REQ_CHANNEL_REGISTER::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_CHANNEL_REGISTER.user)
}

// int32 channelID = 2;
inline void P_C_REQ_CHANNEL_REGISTER::clear_channelid() {
  _impl_.channelid_ = 0;
}
inline int32_t P_C_REQ_CHANNEL_REGISTER::_internal_channelid() const {
  return _impl_.channelid_;
}
inline int32_t P_C_REQ_CHANNEL_REGISTER::channelid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHANNEL_REGISTER.channelID)
  return _internal_channelid();
}
inline void P_C_REQ_CHANNEL_REGISTER::_internal_set_channelid(int32_t value) {
  
  _impl_.channelid_ = value;
}
inline void P_C_REQ_CHANNEL_REGISTER::set_channelid(int32_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHANNEL_REGISTER.channelID)
}

// -------------------------------------------------------------------

// P_S_RES_CHANNEL_REGISTER

// .neo.PacketResult result = 1;
inline void P_S_RES_CHANNEL_REGISTER::clear_result() {
  _impl_.result_ = 0;
}
inline ::neo::PacketResult P_S_RES_CHANNEL_REGISTER::_internal_result() const {
  return static_cast< ::neo::PacketResult >(_impl_.result_);
}
inline ::neo::PacketResult P_S_RES_CHANNEL_REGISTER::result() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_CHANNEL_REGISTER.result)
  return _internal_result();
}
inline void P_S_RES_CHANNEL_REGISTER::_internal_set_result(::neo::PacketResult value) {
  
  _impl_.result_ = value;
}
inline void P_S_RES_CHANNEL_REGISTER::set_result(::neo::PacketResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:neo.P_S_RES_CHANNEL_REGISTER.result)
}

// int32 channelID = 2;
inline void P_S_RES_CHANNEL_REGISTER::clear_channelid() {
  _impl_.channelid_ = 0;
}
inline int32_t P_S_RES_CHANNEL_REGISTER::_internal_channelid() const {
  return _impl_.channelid_;
}
inline int32_t P_S_RES_CHANNEL_REGISTER::channelid() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_CHANNEL_REGISTER.channelID)
  return _internal_channelid();
}
inline void P_S_RES_CHANNEL_REGISTER::_internal_set_channelid(int32_t value) {
  
  _impl_.channelid_ = value;
}
inline void P_S_RES_CHANNEL_REGISTER::set_channelid(int32_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:neo.P_S_RES_CHANNEL_REGISTER.channelID)
}

// string msg = 3;
inline void P_S_RES_CHANNEL_REGISTER::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& P_S_RES_CHANNEL_REGISTER::msg() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_CHANNEL_REGISTER.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_RES_CHANNEL_REGISTER::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_RES_CHANNEL_REGISTER.msg)
}
inline std::string* P_S_RES_CHANNEL_REGISTER::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:neo.P_S_RES_CHANNEL_REGISTER.msg)
  return _s;
}
inline const std::string& P_S_RES_CHANNEL_REGISTER::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void P_S_RES_CHANNEL_REGISTER::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_RES_CHANNEL_REGISTER::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_RES_CHANNEL_REGISTER::release_msg() {
  // @@protoc_insertion_point(field_release:neo.P_S_RES_CHANNEL_REGISTER.msg)
  return _impl_.msg_.Release();
}
inline void P_S_RES_CHANNEL_REGISTER::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_RES_CHANNEL_REGISTER.msg)
}

// -------------------------------------------------------------------

// P_C_NOTIFY_CHANNEL_UNREGISTER

// int32 result = 1;
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_result() const {
  return _impl_.result_;
}
inline int32_t P_C_NOTIFY_CHANNEL_UNREGISTER::result() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.result)
  return _internal_result();
}
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.result)
}

// int32 channelID = 2;
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::clear_channelid() {
  _impl_.channelid_ = 0;
}
inline int32_t P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_channelid() const {
  return _impl_.channelid_;
}
inline int32_t P_C_NOTIFY_CHANNEL_UNREGISTER::channelid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.channelID)
  return _internal_channelid();
}
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_set_channelid(int32_t value) {
  
  _impl_.channelid_ = value;
}
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::set_channelid(int32_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.channelID)
}

// string msg = 3;
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& P_C_NOTIFY_CHANNEL_UNREGISTER::msg() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_NOTIFY_CHANNEL_UNREGISTER::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.msg)
}
inline std::string* P_C_NOTIFY_CHANNEL_UNREGISTER::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.msg)
  return _s;
}
inline const std::string& P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_NOTIFY_CHANNEL_UNREGISTER::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_NOTIFY_CHANNEL_UNREGISTER::release_msg() {
  // @@protoc_insertion_point(field_release:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.msg)
  return _impl_.msg_.Release();
}
inline void P_C_NOTIFY_CHANNEL_UNREGISTER::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_NOTIFY_CHANNEL_UNREGISTER.msg)
}

// -------------------------------------------------------------------

// P_C_NOTIFY_MAP_REGISTER

// int32 mapCount = 1;
inline void P_C_NOTIFY_MAP_REGISTER::clear_mapcount() {
  _impl_.mapcount_ = 0;
}
inline int32_t P_C_NOTIFY_MAP_REGISTER::_internal_mapcount() const {
  return _impl_.mapcount_;
}
inline int32_t P_C_NOTIFY_MAP_REGISTER::mapcount() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_MAP_REGISTER.mapCount)
  return _internal_mapcount();
}
inline void P_C_NOTIFY_MAP_REGISTER::_internal_set_mapcount(int32_t value) {
  
  _impl_.mapcount_ = value;
}
inline void P_C_NOTIFY_MAP_REGISTER::set_mapcount(int32_t value) {
  _internal_set_mapcount(value);
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_MAP_REGISTER.mapCount)
}

// bool isRegister = 2;
inline void P_C_NOTIFY_MAP_REGISTER::clear_isregister() {
  _impl_.isregister_ = false;
}
inline bool P_C_NOTIFY_MAP_REGISTER::_internal_isregister() const {
  return _impl_.isregister_;
}
inline bool P_C_NOTIFY_MAP_REGISTER::isregister() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_MAP_REGISTER.isRegister)
  return _internal_isregister();
}
inline void P_C_NOTIFY_MAP_REGISTER::_internal_set_isregister(bool value) {
  
  _impl_.isregister_ = value;
}
inline void P_C_NOTIFY_MAP_REGISTER::set_isregister(bool value) {
  _internal_set_isregister(value);
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_MAP_REGISTER.isRegister)
}

// string name = 3;
inline void P_C_NOTIFY_MAP_REGISTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_C_NOTIFY_MAP_REGISTER::name() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_MAP_REGISTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_NOTIFY_MAP_REGISTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_MAP_REGISTER.name)
}
inline std::string* P_C_NOTIFY_MAP_REGISTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_C_NOTIFY_MAP_REGISTER.name)
  return _s;
}
inline const std::string& P_C_NOTIFY_MAP_REGISTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_C_NOTIFY_MAP_REGISTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_NOTIFY_MAP_REGISTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_NOTIFY_MAP_REGISTER::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_C_NOTIFY_MAP_REGISTER.name)
  return _impl_.name_.Release();
}
inline void P_C_NOTIFY_MAP_REGISTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_NOTIFY_MAP_REGISTER.name)
}

// -------------------------------------------------------------------

// P_C_REQ_CHARACTER_REGISTER

// string name = 1;
inline void P_C_REQ_CHARACTER_REGISTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_C_REQ_CHARACTER_REGISTER::name() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_REGISTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_CHARACTER_REGISTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_REGISTER.name)
}
inline std::string* P_C_REQ_CHARACTER_REGISTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_CHARACTER_REGISTER.name)
  return _s;
}
inline const std::string& P_C_REQ_CHARACTER_REGISTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_C_REQ_CHARACTER_REGISTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_CHARACTER_REGISTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_CHARACTER_REGISTER::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_CHARACTER_REGISTER.name)
  return _impl_.name_.Release();
}
inline void P_C_REQ_CHARACTER_REGISTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_CHARACTER_REGISTER.name)
}

// int32 mapID = 2;
inline void P_C_REQ_CHARACTER_REGISTER::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_C_REQ_CHARACTER_REGISTER::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_C_REQ_CHARACTER_REGISTER::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_REGISTER.mapID)
  return _internal_mapid();
}
inline void P_C_REQ_CHARACTER_REGISTER::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_C_REQ_CHARACTER_REGISTER::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_REGISTER.mapID)
}

// float x = 3;
inline void P_C_REQ_CHARACTER_REGISTER::clear_x() {
  _impl_.x_ = 0;
}
inline float P_C_REQ_CHARACTER_REGISTER::_internal_x() const {
  return _impl_.x_;
}
inline float P_C_REQ_CHARACTER_REGISTER::x() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_REGISTER.x)
  return _internal_x();
}
inline void P_C_REQ_CHARACTER_REGISTER::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void P_C_REQ_CHARACTER_REGISTER::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_REGISTER.x)
}

// float y = 4;
inline void P_C_REQ_CHARACTER_REGISTER::clear_y() {
  _impl_.y_ = 0;
}
inline float P_C_REQ_CHARACTER_REGISTER::_internal_y() const {
  return _impl_.y_;
}
inline float P_C_REQ_CHARACTER_REGISTER::y() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_REGISTER.y)
  return _internal_y();
}
inline void P_C_REQ_CHARACTER_REGISTER::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void P_C_REQ_CHARACTER_REGISTER::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_REGISTER.y)
}

// float z = 5;
inline void P_C_REQ_CHARACTER_REGISTER::clear_z() {
  _impl_.z_ = 0;
}
inline float P_C_REQ_CHARACTER_REGISTER::_internal_z() const {
  return _impl_.z_;
}
inline float P_C_REQ_CHARACTER_REGISTER::z() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_REGISTER.z)
  return _internal_z();
}
inline void P_C_REQ_CHARACTER_REGISTER::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void P_C_REQ_CHARACTER_REGISTER::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_REGISTER.z)
}

// -------------------------------------------------------------------

// P_S_RES_CHARACTER_REGISTER

// int32 result = 1;
inline void P_S_RES_CHARACTER_REGISTER::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t P_S_RES_CHARACTER_REGISTER::_internal_result() const {
  return _impl_.result_;
}
inline int32_t P_S_RES_CHARACTER_REGISTER::result() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_CHARACTER_REGISTER.result)
  return _internal_result();
}
inline void P_S_RES_CHARACTER_REGISTER::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void P_S_RES_CHARACTER_REGISTER::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:neo.P_S_RES_CHARACTER_REGISTER.result)
}

// string msg = 2;
inline void P_S_RES_CHARACTER_REGISTER::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& P_S_RES_CHARACTER_REGISTER::msg() const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_CHARACTER_REGISTER.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_RES_CHARACTER_REGISTER::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_RES_CHARACTER_REGISTER.msg)
}
inline std::string* P_S_RES_CHARACTER_REGISTER::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:neo.P_S_RES_CHARACTER_REGISTER.msg)
  return _s;
}
inline const std::string& P_S_RES_CHARACTER_REGISTER::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void P_S_RES_CHARACTER_REGISTER::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_RES_CHARACTER_REGISTER::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_RES_CHARACTER_REGISTER::release_msg() {
  // @@protoc_insertion_point(field_release:neo.P_S_RES_CHARACTER_REGISTER.msg)
  return _impl_.msg_.Release();
}
inline void P_S_RES_CHARACTER_REGISTER::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_RES_CHARACTER_REGISTER.msg)
}

// repeated .neo.GAME_OBJECT objects = 3;
inline int P_S_RES_CHARACTER_REGISTER::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int P_S_RES_CHARACTER_REGISTER::objects_size() const {
  return _internal_objects_size();
}
inline void P_S_RES_CHARACTER_REGISTER::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::neo::GAME_OBJECT* P_S_RES_CHARACTER_REGISTER::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:neo.P_S_RES_CHARACTER_REGISTER.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::GAME_OBJECT >*
P_S_RES_CHARACTER_REGISTER::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:neo.P_S_RES_CHARACTER_REGISTER.objects)
  return &_impl_.objects_;
}
inline const ::neo::GAME_OBJECT& P_S_RES_CHARACTER_REGISTER::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::neo::GAME_OBJECT& P_S_RES_CHARACTER_REGISTER::objects(int index) const {
  // @@protoc_insertion_point(field_get:neo.P_S_RES_CHARACTER_REGISTER.objects)
  return _internal_objects(index);
}
inline ::neo::GAME_OBJECT* P_S_RES_CHARACTER_REGISTER::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::neo::GAME_OBJECT* P_S_RES_CHARACTER_REGISTER::add_objects() {
  ::neo::GAME_OBJECT* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:neo.P_S_RES_CHARACTER_REGISTER.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::GAME_OBJECT >&
P_S_RES_CHARACTER_REGISTER::objects() const {
  // @@protoc_insertion_point(field_list:neo.P_S_RES_CHARACTER_REGISTER.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// P_C_REQ_CHARACTER_MAP_UNREGISTER

// int32 mapID = 1;
inline void P_C_REQ_CHARACTER_MAP_UNREGISTER::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_C_REQ_CHARACTER_MAP_UNREGISTER::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_C_REQ_CHARACTER_MAP_UNREGISTER::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.mapID)
  return _internal_mapid();
}
inline void P_C_REQ_CHARACTER_MAP_UNREGISTER::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_C_REQ_CHARACTER_MAP_UNREGISTER::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.mapID)
}

// string name = 2;
inline void P_C_REQ_CHARACTER_MAP_UNREGISTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_C_REQ_CHARACTER_MAP_UNREGISTER::name() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_CHARACTER_MAP_UNREGISTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.name)
}
inline std::string* P_C_REQ_CHARACTER_MAP_UNREGISTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.name)
  return _s;
}
inline const std::string& P_C_REQ_CHARACTER_MAP_UNREGISTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_C_REQ_CHARACTER_MAP_UNREGISTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_CHARACTER_MAP_UNREGISTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_CHARACTER_MAP_UNREGISTER::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.name)
  return _impl_.name_.Release();
}
inline void P_C_REQ_CHARACTER_MAP_UNREGISTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_CHARACTER_MAP_UNREGISTER.name)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_CHARACTER_MAP_UNREGISTER

// int32 mapID = 1;
inline void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.mapID)
  return _internal_mapid();
}
inline void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.mapID)
}

// string name = 2;
inline void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::name() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.name)
}
inline std::string* P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.name)
  return _s;
}
inline const std::string& P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.name)
  return _impl_.name_.Release();
}
inline void P_S_NOTIFY_CHARACTER_MAP_UNREGISTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_CHARACTER_MAP_UNREGISTER.name)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_MONSTER_MAP_REGISTER

// int32 mapID = 1;
inline void P_S_NOTIFY_MONSTER_MAP_REGISTER::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_S_NOTIFY_MONSTER_MAP_REGISTER::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_S_NOTIFY_MONSTER_MAP_REGISTER::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.mapID)
  return _internal_mapid();
}
inline void P_S_NOTIFY_MONSTER_MAP_REGISTER::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_S_NOTIFY_MONSTER_MAP_REGISTER::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.mapID)
}

// string name = 2;
inline void P_S_NOTIFY_MONSTER_MAP_REGISTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_MONSTER_MAP_REGISTER::name() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_MONSTER_MAP_REGISTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.name)
}
inline std::string* P_S_NOTIFY_MONSTER_MAP_REGISTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.name)
  return _s;
}
inline const std::string& P_S_NOTIFY_MONSTER_MAP_REGISTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_S_NOTIFY_MONSTER_MAP_REGISTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_MAP_REGISTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_MAP_REGISTER::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.name)
  return _impl_.name_.Release();
}
inline void P_S_NOTIFY_MONSTER_MAP_REGISTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_MONSTER_MAP_REGISTER.name)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_MONSTER_MAP_UNREGISTER

// int32 mapID = 1;
inline void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_S_NOTIFY_MONSTER_MAP_UNREGISTER::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_S_NOTIFY_MONSTER_MAP_UNREGISTER::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.mapID)
  return _internal_mapid();
}
inline void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.mapID)
}

// string name = 2;
inline void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_MONSTER_MAP_UNREGISTER::name() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.name)
}
inline std::string* P_S_NOTIFY_MONSTER_MAP_UNREGISTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.name)
  return _s;
}
inline const std::string& P_S_NOTIFY_MONSTER_MAP_UNREGISTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_MAP_UNREGISTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_MAP_UNREGISTER::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.name)
  return _impl_.name_.Release();
}
inline void P_S_NOTIFY_MONSTER_MAP_UNREGISTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_MONSTER_MAP_UNREGISTER.name)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_ATTACK_ANI_EVENT

// int32 mapID = 1;
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_S_NOTIFY_ATTACK_ANI_EVENT::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.mapID)
  return _internal_mapid();
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.mapID)
}

// int32 dir = 2;
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::clear_dir() {
  _impl_.dir_ = 0;
}
inline int32_t P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_dir() const {
  return _impl_.dir_;
}
inline int32_t P_S_NOTIFY_ATTACK_ANI_EVENT::dir() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.dir)
  return _internal_dir();
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_set_dir(int32_t value) {
  
  _impl_.dir_ = value;
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::set_dir(int32_t value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.dir)
}

// int32 animationCount = 3;
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::clear_animationcount() {
  _impl_.animationcount_ = 0;
}
inline int32_t P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_animationcount() const {
  return _impl_.animationcount_;
}
inline int32_t P_S_NOTIFY_ATTACK_ANI_EVENT::animationcount() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.animationCount)
  return _internal_animationcount();
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_set_animationcount(int32_t value) {
  
  _impl_.animationcount_ = value;
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::set_animationcount(int32_t value) {
  _internal_set_animationcount(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.animationCount)
}

// string player = 4;
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::clear_player() {
  _impl_.player_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_ATTACK_ANI_EVENT::player() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.player)
  return _internal_player();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_ATTACK_ANI_EVENT::set_player(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.player)
}
inline std::string* P_S_NOTIFY_ATTACK_ANI_EVENT::mutable_player() {
  std::string* _s = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.player)
  return _s;
}
inline const std::string& P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_player() const {
  return _impl_.player_.Get();
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_set_player(const std::string& value) {
  
  _impl_.player_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_ATTACK_ANI_EVENT::_internal_mutable_player() {
  
  return _impl_.player_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_ATTACK_ANI_EVENT::release_player() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.player)
  return _impl_.player_.Release();
}
inline void P_S_NOTIFY_ATTACK_ANI_EVENT::set_allocated_player(std::string* player) {
  if (player != nullptr) {
    
  } else {
    
  }
  _impl_.player_.SetAllocated(player, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_.IsDefault()) {
    _impl_.player_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_ATTACK_ANI_EVENT.player)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_CHARACTER_INFO

// string name = 1;
inline void P_S_NOTIFY_CHARACTER_INFO::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_CHARACTER_INFO::name() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHARACTER_INFO.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_CHARACTER_INFO::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_CHARACTER_INFO.name)
}
inline std::string* P_S_NOTIFY_CHARACTER_INFO::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_CHARACTER_INFO.name)
  return _s;
}
inline const std::string& P_S_NOTIFY_CHARACTER_INFO::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_S_NOTIFY_CHARACTER_INFO::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_CHARACTER_INFO::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_CHARACTER_INFO::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_CHARACTER_INFO.name)
  return _impl_.name_.Release();
}
inline void P_S_NOTIFY_CHARACTER_INFO::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_CHARACTER_INFO.name)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA

// string name = 1;
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::name() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.name)
}
inline std::string* P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.name)
  return _s;
}
inline const std::string& P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.name)
  return _impl_.name_.Release();
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.name)
}

// float pos_x = 2;
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::clear_pos_x() {
  _impl_.pos_x_ = 0;
}
inline float P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_pos_x() const {
  return _impl_.pos_x_;
}
inline float P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::pos_x() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.pos_x)
  return _internal_pos_x();
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_set_pos_x(float value) {
  
  _impl_.pos_x_ = value;
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.pos_x)
}

// float pos_y = 3;
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::clear_pos_y() {
  _impl_.pos_y_ = 0;
}
inline float P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_pos_y() const {
  return _impl_.pos_y_;
}
inline float P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::pos_y() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.pos_y)
  return _internal_pos_y();
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_set_pos_y(float value) {
  
  _impl_.pos_y_ = value;
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.pos_y)
}

// int32 hp = 4;
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::hp() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.hp)
  return _internal_hp();
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA.hp)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_MONSTER_INFO

// int32 monsterCode = 1;
inline void P_S_NOTIFY_MONSTER_INFO::clear_monstercode() {
  _impl_.monstercode_ = 0;
}
inline int32_t P_S_NOTIFY_MONSTER_INFO::_internal_monstercode() const {
  return _impl_.monstercode_;
}
inline int32_t P_S_NOTIFY_MONSTER_INFO::monstercode() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.monsterCode)
  return _internal_monstercode();
}
inline void P_S_NOTIFY_MONSTER_INFO::_internal_set_monstercode(int32_t value) {
  
  _impl_.monstercode_ = value;
}
inline void P_S_NOTIFY_MONSTER_INFO::set_monstercode(int32_t value) {
  _internal_set_monstercode(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_INFO.monsterCode)
}

// string msg = 2;
inline void P_S_NOTIFY_MONSTER_INFO::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_MONSTER_INFO::msg() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_MONSTER_INFO::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_MONSTER_INFO.msg)
}
inline std::string* P_S_NOTIFY_MONSTER_INFO::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_INFO.msg)
  return _s;
}
inline const std::string& P_S_NOTIFY_MONSTER_INFO::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void P_S_NOTIFY_MONSTER_INFO::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_INFO::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_MONSTER_INFO::release_msg() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_MONSTER_INFO.msg)
  return _impl_.msg_.Release();
}
inline void P_S_NOTIFY_MONSTER_INFO::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_MONSTER_INFO.msg)
}

// repeated .neo.P_S_NOTIFY_MONSTER_INFO.MONSTER_DATA monsterDatas = 3;
inline int P_S_NOTIFY_MONSTER_INFO::_internal_monsterdatas_size() const {
  return _impl_.monsterdatas_.size();
}
inline int P_S_NOTIFY_MONSTER_INFO::monsterdatas_size() const {
  return _internal_monsterdatas_size();
}
inline void P_S_NOTIFY_MONSTER_INFO::clear_monsterdatas() {
  _impl_.monsterdatas_.Clear();
}
inline ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* P_S_NOTIFY_MONSTER_INFO::mutable_monsterdatas(int index) {
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_MONSTER_INFO.monsterDatas)
  return _impl_.monsterdatas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA >*
P_S_NOTIFY_MONSTER_INFO::mutable_monsterdatas() {
  // @@protoc_insertion_point(field_mutable_list:neo.P_S_NOTIFY_MONSTER_INFO.monsterDatas)
  return &_impl_.monsterdatas_;
}
inline const ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& P_S_NOTIFY_MONSTER_INFO::_internal_monsterdatas(int index) const {
  return _impl_.monsterdatas_.Get(index);
}
inline const ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA& P_S_NOTIFY_MONSTER_INFO::monsterdatas(int index) const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_MONSTER_INFO.monsterDatas)
  return _internal_monsterdatas(index);
}
inline ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* P_S_NOTIFY_MONSTER_INFO::_internal_add_monsterdatas() {
  return _impl_.monsterdatas_.Add();
}
inline ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* P_S_NOTIFY_MONSTER_INFO::add_monsterdatas() {
  ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA* _add = _internal_add_monsterdatas();
  // @@protoc_insertion_point(field_add:neo.P_S_NOTIFY_MONSTER_INFO.monsterDatas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_MONSTER_INFO_MONSTER_DATA >&
P_S_NOTIFY_MONSTER_INFO::monsterdatas() const {
  // @@protoc_insertion_point(field_list:neo.P_S_NOTIFY_MONSTER_INFO.monsterDatas)
  return _impl_.monsterdatas_;
}

// -------------------------------------------------------------------

// P_C_REQ_ATTACK_RANGE_HIT_EVENT

// int32 mapID = 1;
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_C_REQ_ATTACK_RANGE_HIT_EVENT::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.mapID)
  return _internal_mapid();
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.mapID)
}

// string attackUser = 2;
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::clear_attackuser() {
  _impl_.attackuser_.ClearToEmpty();
}
inline const std::string& P_C_REQ_ATTACK_RANGE_HIT_EVENT::attackuser() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.attackUser)
  return _internal_attackuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_ATTACK_RANGE_HIT_EVENT::set_attackuser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attackuser_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.attackUser)
}
inline std::string* P_C_REQ_ATTACK_RANGE_HIT_EVENT::mutable_attackuser() {
  std::string* _s = _internal_mutable_attackuser();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.attackUser)
  return _s;
}
inline const std::string& P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_attackuser() const {
  return _impl_.attackuser_.Get();
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_set_attackuser(const std::string& value) {
  
  _impl_.attackuser_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_mutable_attackuser() {
  
  return _impl_.attackuser_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_RANGE_HIT_EVENT::release_attackuser() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.attackUser)
  return _impl_.attackuser_.Release();
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::set_allocated_attackuser(std::string* attackuser) {
  if (attackuser != nullptr) {
    
  } else {
    
  }
  _impl_.attackuser_.SetAllocated(attackuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attackuser_.IsDefault()) {
    _impl_.attackuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.attackUser)
}

// string hitObject = 3;
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::clear_hitobject() {
  _impl_.hitobject_.ClearToEmpty();
}
inline const std::string& P_C_REQ_ATTACK_RANGE_HIT_EVENT::hitobject() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.hitObject)
  return _internal_hitobject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_ATTACK_RANGE_HIT_EVENT::set_hitobject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hitobject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.hitObject)
}
inline std::string* P_C_REQ_ATTACK_RANGE_HIT_EVENT::mutable_hitobject() {
  std::string* _s = _internal_mutable_hitobject();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.hitObject)
  return _s;
}
inline const std::string& P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_hitobject() const {
  return _impl_.hitobject_.Get();
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_set_hitobject(const std::string& value) {
  
  _impl_.hitobject_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_mutable_hitobject() {
  
  return _impl_.hitobject_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_RANGE_HIT_EVENT::release_hitobject() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.hitObject)
  return _impl_.hitobject_.Release();
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::set_allocated_hitobject(std::string* hitobject) {
  if (hitobject != nullptr) {
    
  } else {
    
  }
  _impl_.hitobject_.SetAllocated(hitobject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hitobject_.IsDefault()) {
    _impl_.hitobject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.hitObject)
}

// int32 damage = 4;
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::clear_damage() {
  _impl_.damage_ = 0;
}
inline int32_t P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_damage() const {
  return _impl_.damage_;
}
inline int32_t P_C_REQ_ATTACK_RANGE_HIT_EVENT::damage() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.damage)
  return _internal_damage();
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::_internal_set_damage(int32_t value) {
  
  _impl_.damage_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_HIT_EVENT::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_HIT_EVENT.damage)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_EFFECT_EVENT

// float startPos_x = 1;
inline void P_S_NOTIFY_EFFECT_EVENT::clear_startpos_x() {
  _impl_.startpos_x_ = 0;
}
inline float P_S_NOTIFY_EFFECT_EVENT::_internal_startpos_x() const {
  return _impl_.startpos_x_;
}
inline float P_S_NOTIFY_EFFECT_EVENT::startpos_x() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_EFFECT_EVENT.startPos_x)
  return _internal_startpos_x();
}
inline void P_S_NOTIFY_EFFECT_EVENT::_internal_set_startpos_x(float value) {
  
  _impl_.startpos_x_ = value;
}
inline void P_S_NOTIFY_EFFECT_EVENT::set_startpos_x(float value) {
  _internal_set_startpos_x(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_EFFECT_EVENT.startPos_x)
}

// float startPos_y = 2;
inline void P_S_NOTIFY_EFFECT_EVENT::clear_startpos_y() {
  _impl_.startpos_y_ = 0;
}
inline float P_S_NOTIFY_EFFECT_EVENT::_internal_startpos_y() const {
  return _impl_.startpos_y_;
}
inline float P_S_NOTIFY_EFFECT_EVENT::startpos_y() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_EFFECT_EVENT.startPos_y)
  return _internal_startpos_y();
}
inline void P_S_NOTIFY_EFFECT_EVENT::_internal_set_startpos_y(float value) {
  
  _impl_.startpos_y_ = value;
}
inline void P_S_NOTIFY_EFFECT_EVENT::set_startpos_y(float value) {
  _internal_set_startpos_y(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_EFFECT_EVENT.startPos_y)
}

// float startPos_z = 3;
inline void P_S_NOTIFY_EFFECT_EVENT::clear_startpos_z() {
  _impl_.startpos_z_ = 0;
}
inline float P_S_NOTIFY_EFFECT_EVENT::_internal_startpos_z() const {
  return _impl_.startpos_z_;
}
inline float P_S_NOTIFY_EFFECT_EVENT::startpos_z() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_EFFECT_EVENT.startPos_z)
  return _internal_startpos_z();
}
inline void P_S_NOTIFY_EFFECT_EVENT::_internal_set_startpos_z(float value) {
  
  _impl_.startpos_z_ = value;
}
inline void P_S_NOTIFY_EFFECT_EVENT::set_startpos_z(float value) {
  _internal_set_startpos_z(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_EFFECT_EVENT.startPos_z)
}

// string attackUser = 4;
inline void P_S_NOTIFY_EFFECT_EVENT::clear_attackuser() {
  _impl_.attackuser_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_EFFECT_EVENT::attackuser() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_EFFECT_EVENT.attackUser)
  return _internal_attackuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_EFFECT_EVENT::set_attackuser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attackuser_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_EFFECT_EVENT.attackUser)
}
inline std::string* P_S_NOTIFY_EFFECT_EVENT::mutable_attackuser() {
  std::string* _s = _internal_mutable_attackuser();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_EFFECT_EVENT.attackUser)
  return _s;
}
inline const std::string& P_S_NOTIFY_EFFECT_EVENT::_internal_attackuser() const {
  return _impl_.attackuser_.Get();
}
inline void P_S_NOTIFY_EFFECT_EVENT::_internal_set_attackuser(const std::string& value) {
  
  _impl_.attackuser_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_EFFECT_EVENT::_internal_mutable_attackuser() {
  
  return _impl_.attackuser_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_EFFECT_EVENT::release_attackuser() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_EFFECT_EVENT.attackUser)
  return _impl_.attackuser_.Release();
}
inline void P_S_NOTIFY_EFFECT_EVENT::set_allocated_attackuser(std::string* attackuser) {
  if (attackuser != nullptr) {
    
  } else {
    
  }
  _impl_.attackuser_.SetAllocated(attackuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attackuser_.IsDefault()) {
    _impl_.attackuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_EFFECT_EVENT.attackUser)
}

// float dis = 5;
inline void P_S_NOTIFY_EFFECT_EVENT::clear_dis() {
  _impl_.dis_ = 0;
}
inline float P_S_NOTIFY_EFFECT_EVENT::_internal_dis() const {
  return _impl_.dis_;
}
inline float P_S_NOTIFY_EFFECT_EVENT::dis() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_EFFECT_EVENT.dis)
  return _internal_dis();
}
inline void P_S_NOTIFY_EFFECT_EVENT::_internal_set_dis(float value) {
  
  _impl_.dis_ = value;
}
inline void P_S_NOTIFY_EFFECT_EVENT::set_dis(float value) {
  _internal_set_dis(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_EFFECT_EVENT.dis)
}

// int32 dir = 6;
inline void P_S_NOTIFY_EFFECT_EVENT::clear_dir() {
  _impl_.dir_ = 0;
}
inline int32_t P_S_NOTIFY_EFFECT_EVENT::_internal_dir() const {
  return _impl_.dir_;
}
inline int32_t P_S_NOTIFY_EFFECT_EVENT::dir() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_EFFECT_EVENT.dir)
  return _internal_dir();
}
inline void P_S_NOTIFY_EFFECT_EVENT::_internal_set_dir(int32_t value) {
  
  _impl_.dir_ = value;
}
inline void P_S_NOTIFY_EFFECT_EVENT::set_dir(int32_t value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_EFFECT_EVENT.dir)
}

// -------------------------------------------------------------------

// P_C_REQ_ATTACK_RANGE_EVENT

// float startPos_x = 1;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_startpos_x() {
  _impl_.startpos_x_ = 0;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::_internal_startpos_x() const {
  return _impl_.startpos_x_;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::startpos_x() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.startPos_x)
  return _internal_startpos_x();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_startpos_x(float value) {
  
  _impl_.startpos_x_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_startpos_x(float value) {
  _internal_set_startpos_x(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.startPos_x)
}

// float startPos_y = 2;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_startpos_y() {
  _impl_.startpos_y_ = 0;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::_internal_startpos_y() const {
  return _impl_.startpos_y_;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::startpos_y() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.startPos_y)
  return _internal_startpos_y();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_startpos_y(float value) {
  
  _impl_.startpos_y_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_startpos_y(float value) {
  _internal_set_startpos_y(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.startPos_y)
}

// float startPos_z = 3;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_startpos_z() {
  _impl_.startpos_z_ = 0;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::_internal_startpos_z() const {
  return _impl_.startpos_z_;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::startpos_z() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.startPos_z)
  return _internal_startpos_z();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_startpos_z(float value) {
  
  _impl_.startpos_z_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_startpos_z(float value) {
  _internal_set_startpos_z(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.startPos_z)
}

// int32 mapID = 4;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.mapID)
  return _internal_mapid();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.mapID)
}

// int32 dir = 5;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_dir() {
  _impl_.dir_ = 0;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::_internal_dir() const {
  return _impl_.dir_;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::dir() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.dir)
  return _internal_dir();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_dir(int32_t value) {
  
  _impl_.dir_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_dir(int32_t value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.dir)
}

// string attackUser = 6;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_attackuser() {
  _impl_.attackuser_.ClearToEmpty();
}
inline const std::string& P_C_REQ_ATTACK_RANGE_EVENT::attackuser() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.attackUser)
  return _internal_attackuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_ATTACK_RANGE_EVENT::set_attackuser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attackuser_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.attackUser)
}
inline std::string* P_C_REQ_ATTACK_RANGE_EVENT::mutable_attackuser() {
  std::string* _s = _internal_mutable_attackuser();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_ATTACK_RANGE_EVENT.attackUser)
  return _s;
}
inline const std::string& P_C_REQ_ATTACK_RANGE_EVENT::_internal_attackuser() const {
  return _impl_.attackuser_.Get();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_attackuser(const std::string& value) {
  
  _impl_.attackuser_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_RANGE_EVENT::_internal_mutable_attackuser() {
  
  return _impl_.attackuser_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_RANGE_EVENT::release_attackuser() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_ATTACK_RANGE_EVENT.attackUser)
  return _impl_.attackuser_.Release();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_allocated_attackuser(std::string* attackuser) {
  if (attackuser != nullptr) {
    
  } else {
    
  }
  _impl_.attackuser_.SetAllocated(attackuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attackuser_.IsDefault()) {
    _impl_.attackuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_ATTACK_RANGE_EVENT.attackUser)
}

// float dis = 7;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_dis() {
  _impl_.dis_ = 0;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::_internal_dis() const {
  return _impl_.dis_;
}
inline float P_C_REQ_ATTACK_RANGE_EVENT::dis() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.dis)
  return _internal_dis();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_dis(float value) {
  
  _impl_.dis_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_dis(float value) {
  _internal_set_dis(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.dis)
}

// int32 damage = 8;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_damage() {
  _impl_.damage_ = 0;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::_internal_damage() const {
  return _impl_.damage_;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::damage() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.damage)
  return _internal_damage();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_damage(int32_t value) {
  
  _impl_.damage_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.damage)
}

// int32 animation = 9;
inline void P_C_REQ_ATTACK_RANGE_EVENT::clear_animation() {
  _impl_.animation_ = 0;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::_internal_animation() const {
  return _impl_.animation_;
}
inline int32_t P_C_REQ_ATTACK_RANGE_EVENT::animation() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_RANGE_EVENT.animation)
  return _internal_animation();
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::_internal_set_animation(int32_t value) {
  
  _impl_.animation_ = value;
}
inline void P_C_REQ_ATTACK_RANGE_EVENT::set_animation(int32_t value) {
  _internal_set_animation(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_RANGE_EVENT.animation)
}

// -------------------------------------------------------------------

// P_C_REQ_ATTACK_EVENT

// int32 mapID = 1;
inline void P_C_REQ_ATTACK_EVENT::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t P_C_REQ_ATTACK_EVENT::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t P_C_REQ_ATTACK_EVENT::mapid() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_EVENT.mapID)
  return _internal_mapid();
}
inline void P_C_REQ_ATTACK_EVENT::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void P_C_REQ_ATTACK_EVENT::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_EVENT.mapID)
}

// string attackUser = 2;
inline void P_C_REQ_ATTACK_EVENT::clear_attackuser() {
  _impl_.attackuser_.ClearToEmpty();
}
inline const std::string& P_C_REQ_ATTACK_EVENT::attackuser() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_EVENT.attackUser)
  return _internal_attackuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_ATTACK_EVENT::set_attackuser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attackuser_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_EVENT.attackUser)
}
inline std::string* P_C_REQ_ATTACK_EVENT::mutable_attackuser() {
  std::string* _s = _internal_mutable_attackuser();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_ATTACK_EVENT.attackUser)
  return _s;
}
inline const std::string& P_C_REQ_ATTACK_EVENT::_internal_attackuser() const {
  return _impl_.attackuser_.Get();
}
inline void P_C_REQ_ATTACK_EVENT::_internal_set_attackuser(const std::string& value) {
  
  _impl_.attackuser_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_EVENT::_internal_mutable_attackuser() {
  
  return _impl_.attackuser_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_EVENT::release_attackuser() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_ATTACK_EVENT.attackUser)
  return _impl_.attackuser_.Release();
}
inline void P_C_REQ_ATTACK_EVENT::set_allocated_attackuser(std::string* attackuser) {
  if (attackuser != nullptr) {
    
  } else {
    
  }
  _impl_.attackuser_.SetAllocated(attackuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attackuser_.IsDefault()) {
    _impl_.attackuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_ATTACK_EVENT.attackUser)
}

// string hitObject = 3;
inline void P_C_REQ_ATTACK_EVENT::clear_hitobject() {
  _impl_.hitobject_.ClearToEmpty();
}
inline const std::string& P_C_REQ_ATTACK_EVENT::hitobject() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_EVENT.hitObject)
  return _internal_hitobject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_REQ_ATTACK_EVENT::set_hitobject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hitobject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_EVENT.hitObject)
}
inline std::string* P_C_REQ_ATTACK_EVENT::mutable_hitobject() {
  std::string* _s = _internal_mutable_hitobject();
  // @@protoc_insertion_point(field_mutable:neo.P_C_REQ_ATTACK_EVENT.hitObject)
  return _s;
}
inline const std::string& P_C_REQ_ATTACK_EVENT::_internal_hitobject() const {
  return _impl_.hitobject_.Get();
}
inline void P_C_REQ_ATTACK_EVENT::_internal_set_hitobject(const std::string& value) {
  
  _impl_.hitobject_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_EVENT::_internal_mutable_hitobject() {
  
  return _impl_.hitobject_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_REQ_ATTACK_EVENT::release_hitobject() {
  // @@protoc_insertion_point(field_release:neo.P_C_REQ_ATTACK_EVENT.hitObject)
  return _impl_.hitobject_.Release();
}
inline void P_C_REQ_ATTACK_EVENT::set_allocated_hitobject(std::string* hitobject) {
  if (hitobject != nullptr) {
    
  } else {
    
  }
  _impl_.hitobject_.SetAllocated(hitobject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hitobject_.IsDefault()) {
    _impl_.hitobject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_REQ_ATTACK_EVENT.hitObject)
}

// int32 dir = 4;
inline void P_C_REQ_ATTACK_EVENT::clear_dir() {
  _impl_.dir_ = 0;
}
inline int32_t P_C_REQ_ATTACK_EVENT::_internal_dir() const {
  return _impl_.dir_;
}
inline int32_t P_C_REQ_ATTACK_EVENT::dir() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_EVENT.dir)
  return _internal_dir();
}
inline void P_C_REQ_ATTACK_EVENT::_internal_set_dir(int32_t value) {
  
  _impl_.dir_ = value;
}
inline void P_C_REQ_ATTACK_EVENT::set_dir(int32_t value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_EVENT.dir)
}

// int32 animation = 5;
inline void P_C_REQ_ATTACK_EVENT::clear_animation() {
  _impl_.animation_ = 0;
}
inline int32_t P_C_REQ_ATTACK_EVENT::_internal_animation() const {
  return _impl_.animation_;
}
inline int32_t P_C_REQ_ATTACK_EVENT::animation() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_EVENT.animation)
  return _internal_animation();
}
inline void P_C_REQ_ATTACK_EVENT::_internal_set_animation(int32_t value) {
  
  _impl_.animation_ = value;
}
inline void P_C_REQ_ATTACK_EVENT::set_animation(int32_t value) {
  _internal_set_animation(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_EVENT.animation)
}

// int32 damage = 6;
inline void P_C_REQ_ATTACK_EVENT::clear_damage() {
  _impl_.damage_ = 0;
}
inline int32_t P_C_REQ_ATTACK_EVENT::_internal_damage() const {
  return _impl_.damage_;
}
inline int32_t P_C_REQ_ATTACK_EVENT::damage() const {
  // @@protoc_insertion_point(field_get:neo.P_C_REQ_ATTACK_EVENT.damage)
  return _internal_damage();
}
inline void P_C_REQ_ATTACK_EVENT::_internal_set_damage(int32_t value) {
  
  _impl_.damage_ = value;
}
inline void P_C_REQ_ATTACK_EVENT::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:neo.P_C_REQ_ATTACK_EVENT.damage)
}

// -------------------------------------------------------------------

// P_S_RES_ATTACK_EVENT

// -------------------------------------------------------------------

// P_S_NOTIFY_ATTACK_EVENT

// string hitObject = 1;
inline void P_S_NOTIFY_ATTACK_EVENT::clear_hitobject() {
  _impl_.hitobject_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_ATTACK_EVENT::hitobject() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_ATTACK_EVENT.hitObject)
  return _internal_hitobject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_ATTACK_EVENT::set_hitobject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hitobject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_ATTACK_EVENT.hitObject)
}
inline std::string* P_S_NOTIFY_ATTACK_EVENT::mutable_hitobject() {
  std::string* _s = _internal_mutable_hitobject();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_ATTACK_EVENT.hitObject)
  return _s;
}
inline const std::string& P_S_NOTIFY_ATTACK_EVENT::_internal_hitobject() const {
  return _impl_.hitobject_.Get();
}
inline void P_S_NOTIFY_ATTACK_EVENT::_internal_set_hitobject(const std::string& value) {
  
  _impl_.hitobject_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_ATTACK_EVENT::_internal_mutable_hitobject() {
  
  return _impl_.hitobject_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_ATTACK_EVENT::release_hitobject() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_ATTACK_EVENT.hitObject)
  return _impl_.hitobject_.Release();
}
inline void P_S_NOTIFY_ATTACK_EVENT::set_allocated_hitobject(std::string* hitobject) {
  if (hitobject != nullptr) {
    
  } else {
    
  }
  _impl_.hitobject_.SetAllocated(hitobject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hitobject_.IsDefault()) {
    _impl_.hitobject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_ATTACK_EVENT.hitObject)
}

// int32 HP = 2;
inline void P_S_NOTIFY_ATTACK_EVENT::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t P_S_NOTIFY_ATTACK_EVENT::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t P_S_NOTIFY_ATTACK_EVENT::hp() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_ATTACK_EVENT.HP)
  return _internal_hp();
}
inline void P_S_NOTIFY_ATTACK_EVENT::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void P_S_NOTIFY_ATTACK_EVENT::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_ATTACK_EVENT.HP)
}

// -------------------------------------------------------------------

// P_C_NOTIFY_RESPAWN

// string id = 1;
inline void P_C_NOTIFY_RESPAWN::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& P_C_NOTIFY_RESPAWN::id() const {
  // @@protoc_insertion_point(field_get:neo.P_C_NOTIFY_RESPAWN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_C_NOTIFY_RESPAWN::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_C_NOTIFY_RESPAWN.id)
}
inline std::string* P_C_NOTIFY_RESPAWN::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:neo.P_C_NOTIFY_RESPAWN.id)
  return _s;
}
inline const std::string& P_C_NOTIFY_RESPAWN::_internal_id() const {
  return _impl_.id_.Get();
}
inline void P_C_NOTIFY_RESPAWN::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* P_C_NOTIFY_RESPAWN::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* P_C_NOTIFY_RESPAWN::release_id() {
  // @@protoc_insertion_point(field_release:neo.P_C_NOTIFY_RESPAWN.id)
  return _impl_.id_.Release();
}
inline void P_C_NOTIFY_RESPAWN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_C_NOTIFY_RESPAWN.id)
}

// -------------------------------------------------------------------

// P_NOTIFY_OBJECT_UPDATE

// -------------------------------------------------------------------

// P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA

// string name = 1;
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::name() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.name)
}
inline std::string* P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.name)
  return _s;
}
inline const std::string& P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_name() const {
  return _impl_.name_.Get();
}
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::release_name() {
  // @@protoc_insertion_point(field_release:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.name)
  return _impl_.name_.Release();
}
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.name)
}

// int32 userCount = 2;
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::clear_usercount() {
  _impl_.usercount_ = 0;
}
inline int32_t P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_usercount() const {
  return _impl_.usercount_;
}
inline int32_t P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::usercount() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.userCount)
  return _internal_usercount();
}
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_set_usercount(int32_t value) {
  
  _impl_.usercount_ = value;
}
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::set_usercount(int32_t value) {
  _internal_set_usercount(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.userCount)
}

// int32 channelID = 3;
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::clear_channelid() {
  _impl_.channelid_ = 0;
}
inline int32_t P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_channelid() const {
  return _impl_.channelid_;
}
inline int32_t P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::channelid() const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.channelID)
  return _internal_channelid();
}
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::_internal_set_channelid(int32_t value) {
  
  _impl_.channelid_ = value;
}
inline void P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA::set_channelid(int32_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA.channelID)
}

// -------------------------------------------------------------------

// P_S_NOTIFY_CHANNEL_INFO

// repeated .neo.P_S_NOTIFY_CHANNEL_INFO.CHANNEL_DATA chaanelInfos = 1;
inline int P_S_NOTIFY_CHANNEL_INFO::_internal_chaanelinfos_size() const {
  return _impl_.chaanelinfos_.size();
}
inline int P_S_NOTIFY_CHANNEL_INFO::chaanelinfos_size() const {
  return _internal_chaanelinfos_size();
}
inline void P_S_NOTIFY_CHANNEL_INFO::clear_chaanelinfos() {
  _impl_.chaanelinfos_.Clear();
}
inline ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* P_S_NOTIFY_CHANNEL_INFO::mutable_chaanelinfos(int index) {
  // @@protoc_insertion_point(field_mutable:neo.P_S_NOTIFY_CHANNEL_INFO.chaanelInfos)
  return _impl_.chaanelinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA >*
P_S_NOTIFY_CHANNEL_INFO::mutable_chaanelinfos() {
  // @@protoc_insertion_point(field_mutable_list:neo.P_S_NOTIFY_CHANNEL_INFO.chaanelInfos)
  return &_impl_.chaanelinfos_;
}
inline const ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& P_S_NOTIFY_CHANNEL_INFO::_internal_chaanelinfos(int index) const {
  return _impl_.chaanelinfos_.Get(index);
}
inline const ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA& P_S_NOTIFY_CHANNEL_INFO::chaanelinfos(int index) const {
  // @@protoc_insertion_point(field_get:neo.P_S_NOTIFY_CHANNEL_INFO.chaanelInfos)
  return _internal_chaanelinfos(index);
}
inline ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* P_S_NOTIFY_CHANNEL_INFO::_internal_add_chaanelinfos() {
  return _impl_.chaanelinfos_.Add();
}
inline ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* P_S_NOTIFY_CHANNEL_INFO::add_chaanelinfos() {
  ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA* _add = _internal_add_chaanelinfos();
  // @@protoc_insertion_point(field_add:neo.P_S_NOTIFY_CHANNEL_INFO.chaanelInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neo::P_S_NOTIFY_CHANNEL_INFO_CHANNEL_DATA >&
P_S_NOTIFY_CHANNEL_INFO::chaanelinfos() const {
  // @@protoc_insertion_point(field_list:neo.P_S_NOTIFY_CHANNEL_INFO.chaanelInfos)
  return _impl_.chaanelinfos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace neo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::neo::PacketID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neo::PacketID>() {
  return ::neo::PacketID_descriptor();
}
template <> struct is_proto_enum< ::neo::PacketResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neo::PacketResult>() {
  return ::neo::PacketResult_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Packet_2eproto
